{
  "abstractText": "With the growing adoption of machine learning techniques, there is a surge of research interest towards making machine learning systems more transparent and interpretable. Various visualizations have been developed to help model developers understand, diagnose, and refine machine learning models. However, a large number of potential but neglected users are the domain experts with little knowledge of machine learning but are expected to work with machine learning systems. In this paper, we present an interactive visualization technique to help users with little expertise in machine learning to understand, explore and validate predictive models. By viewing the model as a black box, we extract a standardized rule-based knowledge representation from its input-output behavior. We design RuleMatrix, a matrix-based visualization of rules to help users navigate and verify the rules and the black-box model. We evaluate the effectiveness of RuleMatrix via two use cases and a usability study.",
  "authors": [
    {
      "affiliations": [],
      "name": "Yao Ming"
    },
    {
      "affiliations": [],
      "name": "Huamin Qu"
    }
  ],
  "id": "SP:a9b57247bfb912fa8919e8d87b68e09ad81d418a",
  "references": [
    {
      "authors": [
        "A. Abdul",
        "J. Vermeulen",
        "D. Wang",
        "B.Y. Lim",
        "M. Kankanhalli"
      ],
      "title": "Trends and trajectories for explainable, accountable and intelligible systems: An hci research agenda",
      "venue": "Proc. CHI Conference on Human Factors in Computing Systems, pp. 582:1\u2013582:18. ACM, New York, NY, USA,",
      "year": 2018
    },
    {
      "authors": [
        "H. Allahyari",
        "N. Lavesson"
      ],
      "title": "User-oriented assessment of classification model understandability",
      "venue": "Proc. 11th Conf. Artificial Inelligence,",
      "year": 2011
    },
    {
      "authors": [
        "R. Andrews",
        "J. Diederich",
        "A.B. Tickle"
      ],
      "title": "Survey and critique of techniques for extracting rules from trained artificial neural networks",
      "venue": "Knowledge-Based Systems, 8(6):373 \u2013 389,",
      "year": 1995
    },
    {
      "authors": [
        "M.G. Augasta",
        "T. Kathirvalavakumar"
      ],
      "title": "Rule extraction from neural networks \u2013 a comparative study",
      "venue": "Proc. Int. Conf. Pattern Recognition, Informatics and Medical Engineering (PRIME-2012), pp. 404\u2013408, Mar",
      "year": 2012
    },
    {
      "authors": [
        "A. Bilal",
        "A. Jourabloo",
        "M. Ye",
        "X. Liu",
        "L. Ren"
      ],
      "title": "Do convolutional neural networks learn class hierarchy",
      "venue": "IEEE Transactions on Visualization and Computer Graphics,",
      "year": 2018
    },
    {
      "authors": [
        "K.D. Bock",
        "K. Coussement",
        "D.V. den Poel"
      ],
      "title": "Ensemble classification based on generalized additive models",
      "venue": "Computational Statistics & Data Analysis,",
      "year": 2010
    },
    {
      "authors": [
        "L. Breiman",
        "J. Friedman",
        "C.J. Stone",
        "R.A. Olshen"
      ],
      "title": "Classification and regression trees",
      "venue": "CRC press,",
      "year": 1984
    },
    {
      "authors": [
        "R. Caruana",
        "Y. Lou",
        "J. Gehrke",
        "P. Koch",
        "M. Sturm",
        "N. Elhadad"
      ],
      "title": "Intelligible models for healthcare: Predicting pneumonia risk and hospital 30-day readmission",
      "venue": "Proc. 21th ACM SIGKDD Int. Conf. Knowledge Discovery and Data Mining, KDD \u201915, pp. 1721\u20131730. ACM, New York, NY, USA,",
      "year": 2015
    },
    {
      "authors": [
        "M.W. Craven",
        "J.W. Shavlik"
      ],
      "title": "Extracting tree-structured representations of trained networks",
      "venue": "Proc. 8th Int. Conf. Neural Information Processing Systems, NIPS\u201995, pp. 24\u201330. MIT Press, Cambridge, MA, USA,",
      "year": 1995
    },
    {
      "authors": [
        "T. Fawcett"
      ],
      "title": "Prie: a system for generating rulelists to maximize roc performance",
      "venue": "Data Mining and Knowledge Discovery, 17(2):207\u2013224, Oct",
      "year": 2008
    },
    {
      "authors": [
        "A.A. Freitas"
      ],
      "title": "Comprehensible classification models: A position paper",
      "venue": "SIGKDD Explor. Newsl., 15(1):1\u201310, Mar",
      "year": 2014
    },
    {
      "authors": [
        "B. Goodman",
        "S. Flaxman"
      ],
      "title": "European union regulations on algorithmic decision-making and a \u201dright to explanation",
      "venue": "AI Magazine, 38(3):50\u201357,",
      "year": 2017
    },
    {
      "authors": [
        "J. Han",
        "J. Pei",
        "Y. Yin"
      ],
      "title": "Mining frequent patterns without candidate generation",
      "venue": "ACM SIGMOD Record, 29(2):1\u201312, May",
      "year": 2000
    },
    {
      "authors": [
        "J. Huysmans",
        "K. Dejaeger",
        "C. Mues",
        "J. Vanthienen",
        "B. Baesens"
      ],
      "title": "An empirical evaluation of the comprehensibility of decision table, tree and rule based predictive models",
      "venue": "Decision Support Systems, 51(1):141 \u2013 154,",
      "year": 2011
    },
    {
      "authors": [
        "M. Kahng",
        "P.Y. Andrews",
        "A. Kalro",
        "D.H. . Chau"
      ],
      "title": "Activis: Visual exploration of industry-scale deep neural network models",
      "venue": "IEEE Transactions on Visualization and Computer Graphics,",
      "year": 2018
    },
    {
      "authors": [
        "J. Krause",
        "A. Dasgupta",
        "J. Swartz",
        "Y. Aphinyanaphongs",
        "E. Bertini"
      ],
      "title": "A workflow for visual diagnostics of binary classifiers using instance-level explanations",
      "venue": "Proc. Visual Analytics Science and Technology (VAST). IEEE, Oct",
      "year": 2017
    },
    {
      "authors": [
        "J. Leike",
        "M. Martic",
        "V. Krakovna",
        "P.A. Ortega",
        "T. Everitt",
        "A. Lefrancq",
        "L. Orseau",
        "S. Legg"
      ],
      "title": "AI safety gridworlds",
      "venue": "arXiv:1711.09883,",
      "year": 2017
    },
    {
      "authors": [
        "B. Letham",
        "C. Rudin",
        "T.H. McCormick",
        "D. Madigan"
      ],
      "title": "Interpretable classifiers using rules and bayesian analysis: Building a better stroke prediction model",
      "venue": "The Annals of Applied Statistics, 9(3):1350\u20131371, Sep",
      "year": 2015
    },
    {
      "authors": [
        "M. Liu",
        "J. Shi",
        "Z. Li",
        "C. Li",
        "J. Zhu",
        "S. Liu"
      ],
      "title": "Towards better analysis of deep convolutional neural networks",
      "venue": "IEEE Transactions on Visualization and Computer Graphics, 23(1):91\u2013100, Jan",
      "year": 2017
    },
    {
      "authors": [
        "S. Liu",
        "X. Wang",
        "M. Liu",
        "J. Zhu"
      ],
      "title": "Towards better analysis of machine learning models: A visual analytics perspective",
      "venue": "Visual Informatics, 1:48\u2013 56,",
      "year": 2017
    },
    {
      "authors": [
        "M. Marchand",
        "M. Sokolova"
      ],
      "title": "Learning with decision lists of datadependent features",
      "venue": "Journal of Machine Learning Research, 6:427\u2013451,",
      "year": 2005
    },
    {
      "authors": [
        "D. Martens",
        "B. Baesens",
        "T.V. Gestel"
      ],
      "title": "Decompositional rule extraction from support vector machines by active learning",
      "venue": "IEEE Transactions on Knowledge and Data Engineering, 21(2):178\u2013191, Feb",
      "year": 2009
    },
    {
      "authors": [
        "Y. Ming",
        "S. Cao",
        "R. Zhang",
        "Z. Li",
        "Y. Chen",
        "Y. Song",
        "H. Qu"
      ],
      "title": "Understanding hidden memories of recurrent neural networks",
      "venue": "Proc. Visual Analytics Science and Technology (VAST). IEEE,",
      "year": 2017
    },
    {
      "authors": [
        "F. Pedregosa",
        "G. Varoquaux",
        "A. Gramfort",
        "V. Michel",
        "B. Thirion",
        "O. Grisel",
        "M. Blondel",
        "P. Prettenhofer",
        "R. Weiss",
        "V. Dubourg",
        "J. Vanderplas",
        "A. Passos",
        "D. Cournapeau",
        "M. Brucher",
        "M. Perrot",
        "E. Duchesnay"
      ],
      "title": "Scikitlearn: Machine learning in Python",
      "venue": "Journal of Machine Learning Research, 12:2825\u20132830,",
      "year": 2011
    },
    {
      "authors": [
        "N. Pezzotti",
        "T. Hllt",
        "J.V. Gemert",
        "B.P.F. Lelieveldt",
        "E. Eisemann",
        "A. Vilanova"
      ],
      "title": "Deepeyes: Progressive visual analytics for designing deep neural networks",
      "venue": "IEEE Transactions on Visualization and Computer Graphics, 24(1):98\u2013108, Jan",
      "year": 2018
    },
    {
      "authors": [
        "J.R. Quinlan"
      ],
      "title": "Generating production rules from decision trees",
      "venue": "Proc. 10th Int. Conf. Artificial Intelligence, IJCAI\u201987, pp. 304\u2013307. Morgan Kaufmann Publishers Inc., San Francisco, CA, USA,",
      "year": 1987
    },
    {
      "authors": [
        "J.R. Quinlan"
      ],
      "title": "Simplifying decision trees",
      "venue": "International Journal of Human- Computer Studies, 27(3):221\u2013234, Sep",
      "year": 1987
    },
    {
      "authors": [
        "P.E. Rauber",
        "S.G. Fadel",
        "A.X. Falco",
        "A.C. Telea"
      ],
      "title": "Visualizing the hidden activity of artificial neural networks",
      "venue": "IEEE Transactions on Visualization and Computer Graphics, 23(1):101\u2013110, Jan",
      "year": 2017
    },
    {
      "authors": [
        "D. Ren",
        "S. Amershi",
        "B. Lee",
        "J. Suh",
        "J.D. Williams"
      ],
      "title": "Squares: Supporting interactive performance analysis for multiclass classifiers",
      "venue": "IEEE Transactions on Visualization and Computer Graphics, 23(1):61\u201370, Jan",
      "year": 2017
    },
    {
      "authors": [
        "M.T. Ribeiro",
        "S. Singh",
        "C. Guestrin"
      ],
      "title": "Why should I trust you?\u201d: Explaining the predictions of any classifier",
      "venue": "Proc. 22nd ACM SIGKDD, KDD \u201916, pp. 1135\u20131144. ACM, New York, NY, USA,",
      "year": 2016
    },
    {
      "authors": [
        "J. Rissanen"
      ],
      "title": "Modeling by shortest data description",
      "venue": "Automatica, 14(5):465 \u2013 471,",
      "year": 1978
    },
    {
      "authors": [
        "R.L. Rivest"
      ],
      "title": "Learning decision lists",
      "venue": "Machine Learning, 2(3):229\u2013246, Nov",
      "year": 1987
    },
    {
      "authors": [
        "D. Sacha",
        "M. Sedlmair",
        "L. Zhang",
        "J.A. Lee",
        "J. Peltonen",
        "D. Weiskopf",
        "S.C. North",
        "D.A. Keim"
      ],
      "title": "What you see is what you can change: Humancentered machine learning by interactive visualization",
      "venue": "Neurocomputing, 268(C):164\u2013175, Dec",
      "year": 2017
    },
    {
      "authors": [
        "H.J. Schulz"
      ],
      "title": "Treevis.net: A tree visualization reference",
      "venue": "IEEE Computer Graphics and Applications,",
      "year": 2011
    },
    {
      "authors": [
        "B.W. Silverman"
      ],
      "title": "Density estimation for statistics and data analysis, vol",
      "venue": "26. CRC press,",
      "year": 1986
    },
    {
      "authors": [
        "K. Simonyan",
        "A. Vedaldi",
        "A. Zisserman"
      ],
      "title": "Deep inside convolutional networks: Visualising image classification models and saliency maps",
      "venue": "Int. Conf. Learning Representations (ICLR) Workshop,",
      "year": 2014
    },
    {
      "authors": [
        "J.W. Smith",
        "J. Everhart",
        "W. Dickson",
        "W. Knowler",
        "R. Johannes"
      ],
      "title": "Using the adap learning algorithm to forecast the onset of diabetes mellitus",
      "venue": "Proc. Annu. Symp. Computer Application in Medical Care, p. 261. American Medical Informatics Association,",
      "year": 1988
    },
    {
      "authors": [
        "H. Strobelt",
        "S. Gehrmann",
        "H. Pfister",
        "A.M. Rush"
      ],
      "title": "Lstmvis: A tool for visual analysis of hidden state dynamics in recurrent neural networks",
      "venue": "IEEE Transactions on Visualization and Computer Graphics, 24(1):667\u2013 676, Jan",
      "year": 2018
    },
    {
      "authors": [
        "E.R. Tufte"
      ],
      "title": "Beautiful Evidence, chap",
      "venue": "2, pp. 46\u201363. Graphis Pr,",
      "year": 2006
    },
    {
      "authors": [
        "F.-Y. Tzeng",
        "K.-L. Ma"
      ],
      "title": "Opening the black box-data driven visualization of neural networks",
      "venue": "Proc. Visualization, pp. 383\u2013390. IEEE,",
      "year": 2005
    },
    {
      "authors": [
        "S. van den Elzen",
        "J.J. van Wijk"
      ],
      "title": "BaobabView: Interactive construction and analysis of decision trees",
      "venue": "In Proc. Visual Analytics Science and Technology (VAST),",
      "year": 2011
    },
    {
      "authors": [
        "J. Vanthienen",
        "G. Wets"
      ],
      "title": "From decision tables to expert system shells",
      "venue": "Data & Knowledge Engineering, 13(3):265\u2013282,",
      "year": 1994
    },
    {
      "authors": [
        "F. Wang",
        "C. Rudin"
      ],
      "title": "Falling Rule Lists",
      "venue": "Proc. 18th Int. Conf. Artificial Intelligence and Statistics, vol. 38, pp. 1013\u20131022. PMLR, San Diego, California, USA,",
      "year": 2015
    },
    {
      "authors": [
        "K. Wongsuphasawat",
        "D. Smilkov",
        "J. Wexler",
        "J. Wilson",
        "D. Man",
        "D. Fritz",
        "D. Krishnan",
        "F.B. Vigas",
        "M. Wattenberg"
      ],
      "title": "Visualizing dataflow graphs 10 To appear in IEEE Transactions on Visualization and Computer Graphics of deep learning models in tensorflow",
      "venue": "IEEE Transactions on Visualization and Computer Graphics, 24(1):1\u201312, Jan",
      "year": 2018
    },
    {
      "authors": [
        "H. Yang",
        "C. Rudin",
        "M. Seltzer"
      ],
      "title": "Scalable Bayesian rule lists",
      "venue": "Proc. 34th Int. Conf. Machine Learning (ICML),",
      "year": 2017
    },
    {
      "authors": [
        "M.D. Zeiler",
        "R. Fergus"
      ],
      "title": "Visualizing and understanding convolutional networks",
      "venue": "ECCV, pp. 818\u2013833. Springer, Cham,",
      "year": 2014
    }
  ],
  "sections": [
    {
      "text": "Index Terms\u2014explainable machine learning, rule visualization, visual analytics"
    },
    {
      "heading": "1 INTRODUCTION",
      "text": "In this paper, we propose an interactive visualization technique for understanding and inspecting machine learning models. By constructing a rule-based interface from a given black box classifier, our method allows visual inspection of the reasoning logic of the model, as well as systematic exploration of the data used to train the model.\nWith the recent advances in machine learning, there is increasing need for transparent and interpretable machine learning models [8, 17, 31]. To avoid ambiguity, in this paper we define interpretability of a machine learning model as the ability to provide explanation for the reasoning of its prediction so that human users can understand. Interpretability is a crucial requirement for machine learning models in\n\u2022 Yao Ming is with Hong Kong University of Science and Technology. E-mail: ymingaa@ust.hk.\n\u2022 Huamin Qu is with Hong Kong University of Science and Technology. E-mail: huamin@cse.ust.hk.\n\u2022 Enrico Bertini is with New York University. Email: enrico.bertini@nyu.edu\napplications where human users are expected to sufficiently understand and trust them. The need for interpretable machine learning has been addressed in medicine, finance, security [18] and many other domains where ethical treatment of data is required [13]. In a health care example given by Caruana et al. [8], logistic regression was chosen over neural networks due to interpretability concerns. Though the neural network achieved a significant higher receiver operating characteristic (ROC) score than the logistic regression, domain experts felt that it was too risky to deploy the neural network for decision making with real patients because of its lack of transparency. On the other hand, with logistic regression, though less accurate, the fitted parameters have relatively clearer meanings, which can facilitate the discovery of problematic patterns in the dataset.\nIn the machine learning literature, trade-offs are often made between performance (e.g., accuracy) and interpretability. Models that are considered interpretable, such as logistic regression, k-nearest neighbors, and decision trees, often perform worse than models that are difficult to interpret, such as neural networks, support vector machines, and\nar X\niv :1\n80 7.\n06 22\n8v 1\nrandom forests. In scenarios where interpretability is required, the use of models with high performance is largely limited. There are two common strategies to strike a balance between performance and interpretability in machine learning. The first develops model simplification techniques (e.g., decision tree simplification [28]) that generate a sparser model without much performance degradation. The second aims to improve the performance by designing models with commonlyrecognized interpretable structures (e.g., the linear relationships used by Generalized Additive Models (GAM) [8] and decision rules employed by Bayesian Rule Lists [19]). However, simplification techniques are applicable to a certain type of model, which impedes their popularization. The newly emerged interpretable models, on the other hand, rarely retain a state-of-the-art performance along with interpretability.\nInstead of struggling with the trade-offs, in this paper we explore the idea of introducing an extra explanatory interface between the human and the model to provide interpretability. The interface is created in two steps. For a trained classification model, we first extract a rule list that approximates the original one using model induction. As a second step, we develop a visual interface to augment interpretability by enabling interactive exploration of details of the decision logic. The visual interface is crucial for numerous reasons. Though rule-based models are commonly considered to be interpretable, their interpretability is largely weakened when the rule list is too long, or the composition of a rule is too complex. In addition, it is hard to identify how well the rules approximate the original model. The visual interface also enables the possibility to inspect the behavior of the model under a production environment, where the operators may not possess much knowledge about the underlying model.\nIn summary, the main contribution of this paper is a visual technique that helps domain experts understand and inspect classification models using rule-based explanation. We present two case studies and a user study to demonstrate the effectiveness of the proposed method. We also contribute a model induction algorithm that generates a rule list for any given classification model."
    },
    {
      "heading": "2 RELATED WORK",
      "text": "Recent research has explored promising directions to make machine learning models explainable. By associating semantic information with a learned deep neural networks, researchers created visualizations that can explain the learned features of the model [37, 47]. In another direction, a variety of algorithms has been developed to directly learn more interpretable and structured models, including generalized additive models [6] and decision rule lists [19, 46]. Most related to our work, model-agnostic induction techniques [9, 31] have been used to generate explanations for any given machine learning model."
    },
    {
      "heading": "2.1 Model Induction",
      "text": "Model induction is a technique that infers an approximate and interpretable model from any machine learning model. The inferred model can be a linear classifier [31], a decision tree [9], or a rule set [23, 27]. It has been increasingly applied to create human-comprehensible proxy models that help users make sense of the behavior of complex models, such as artificial neural networks and support vector machines (SVMs). One most desirable advantage of model induction is that it provides interpretability by treating any complex model as a black box without compromising the performance.\nThere are mainly three types of methods to derive approximate models (often as rule sets) as summarized in related surveys [3, 4], namely, decompositional, pedagogical and eclectic. Decompositional methods extract a simplified representation from specialized structures of a given model, e.g., the weights of a neural network, or the support vectors of an SVM, and thus only work for certain types of models. Pedagogical methods are often model-agnostic, and learn a model that approximates the input-output behavior of the original one. Eclectic methods either combine the previous two, or have distinct differences from them. In this paper, we adopt pedagogical methods to obtain rule-based approximations due to their simplicity and generalizability.\nHowever, as the complexity of the original model increases, model induction would also face trade-offs. We either learn a small and\ncomprehensible model that fails to approximate the original model well, or we learn a well-approximated but large model (e.g., a decision tree with over 100 nodes) that can be hardly recognized as \u201ceasy-tounderstand\u201d. In our work, we utilize visualization techniques to boost the interpretability while maintaining a good approximation quality."
    },
    {
      "heading": "2.2 Visualization for Model Analysis",
      "text": "Visualization has been increasingly used to support the understanding, diagnosis and refinement of machine learning models [1, 21]. In pioneering work by Tzeng and Ma [41], a node-linked visualization is used to understand and analyze a trained neural network\u2019s behavior in classifying volume and text data.\nMore recently, a number of visual analytics methods have been developed to support the analysis of complex deep neural networks [5, 20, 24, 26, 29, 34, 39]. Liu et al. [20] used a hybrid visualization that embedded debugging information into the node-link diagram to help diagnose convolutional neural networks (CNNs). Alsallakh et al. [5] stepped further to examine whether CNNs learn hierarchical representations from image data. Rauber et al. [29] and Pezzotti et al. [26] applied projection techniques to investigate the hidden activities of deep neural networks. Ming et al. [24] developed a visual analytics method based on co-clustering to understand the hidden memories of recurrent neural networks (RNNs) in natural language processing tasks. Strobelt et al. [39] utilized parallel coordinates to help researchers validate hypotheses about the hidden state dynamics of RNNs. Sacha et al. [34] introduced a human-centered visual analytics framework to incorporate human knowledge in the machine learning process.\nIn the meantime, there are concrete demands in the industry to apply visualization to assist the development of machine learning systems [16, 45]. Kahng et al. [16] developed ActiVis, a visual system to support the exploration of industrial deep learning models in Facebook. Wongsuphasawat et al. [45] presented the TensorFlow Graph Visualizer, an integrated visualization tool to help developers understand the complex structure of different machine learning architectures.\nThese methods have addressed the need for better visualization tools for machine learning researchers and developers. However, little attention has been paid to help domain experts (e.g., doctors and analysts) who have little or no knowledge of machine learning or deep learning to understand and exploit this powerful technology. Krause et al. [17] developed an overview-feature-item workflow to help explain machine learning models to domain experts operating a hospital. Such nonexperts in machine learning are the major target users of our solution."
    },
    {
      "heading": "2.3 Visualization of Rule-based Representations",
      "text": "Rule-based models are composed of logical representations, that is, IFTHEN-ELSE statements which are pervasively used in programming languages. Typical representations of rule-based models include decision tables [43], decision trees [7], and rule sets or decision lists [33]. Among these representations, trees are hierarchical data that have been studied abundantly in visualization research. A gallery of tree visualization can be found on treevis.net [35]. Most related to our work, BaobabView [42] uses a node-link data flow diagram to visualize the logic of decision trees, which inspired our design of data flow visualization in rule lists.\nHowever, there is little research on how visualization can help analyze decision tables and rule lists. The lack of interest in visualizing decision tables and rule lists is partially due to the fact that they are not naturally graphical representations as trees. There is also no consensus that trees are the best visual representations for understanding rule-based models. A comprehensive empirical study conducted by Huysmans et al. [15] found that decision tables are the most effective representations, while other studies [2] disagrees. In a later position paper [12], Freitas summarized a few good properties rules and tables possess that trees do not. Also, all previous studies used pure texts to present rules. In our study, we provide a graphical representation of rule lists as an alternative for navigating and exploring proxy models.\nTo appear in IEEE Transactions on Visualization and Computer Graphics"
    },
    {
      "heading": "3 A RULE-BASED EXPLANATION PIPELINE",
      "text": "In this section, we introduce our pipeline for creating a rule-based visual interface that helps domain experts understand, validate, and inspect the behavior of a machine learning model."
    },
    {
      "heading": "3.1 Goals and Target Users",
      "text": "In visualization research, most existing work for interpreting machine learning models focuses on helping model developers understand, diagnose and refine models. In this paper, we target our method at a large number of potential but neglected users \u2013 the experts in various domains that are impacted by the emerging machine learning techniques (e.g., health care, finance, security, and policymakers). With the increasing adoption of machine learning in these domains, however, experts may only have little knowledge of machine learning algorithms but would like to or are required to use them to assist in their decision making.\nThe primary goal of these potential users, unlike model developers, is to fully understand how a model behaves so that they can better use it and work with it. Before they can fully adopt a model, adequate trust about how the model generally behaves need to be established. Once a model is learned and deployed, they would still need to verify its predictions in case of failure. Specifically, our goal is to help the domain experts answer the following questions:\nQ1 What knowledge has the model learned? A trained machine learning model can be seen as an extracted representation of knowledge from the data. We propose to present a unified and understandable form of learned knowledge for any given model as rules (i.e., IF-THEN statements). Here each piece of knowledge consists of two parts: the antecedent (IF) and the consequent (THEN). In this way, users can focus on understanding the learned knowledge itself without extra burden of dealing with different representations.\nQ2 How certain is the model for each piece of knowledge? There are two types of certainty that we should consider: the confidence (the probability that a rule is true according to the model) and the support (the amount of data in support of a rule). Low confidence means that the rule cannot separate the classes apart, while a low support indicates that there is little evidence for the rule. These are important metrics that help the experts decide whether to accept or reject the learned knowledge."
    },
    {
      "heading": "Q3 What knowledge does the model utilize to make a prediction?",
      "text": "This is the same question as \u201cWhy does the model predict x as y\u201d. Unlike the previous two questions, this question is about verifying the model\u2019s prediction on a single instance or a subset of instances, instead of understanding the model in general. This is crucial when users prefer to verify the reasons for a model\u2019s prediction than to blindly trust it. For example, a doctor would want to understand the reasons of an automatic diagnosis before making a final decision. Domain experts may have knowledge and theories that are originated in years of research and study, which is what current machine learning models fail to utilize.\nQ4 When and where is the model likely to fail? This question arises when a model does not perform well on out-of-sample data. A rule that the model is confident about may not be generalizable in the production. Though undesirable, it is not rare that a model gives a highly confident but wrong prediction. Thus, we need to provide guidance on when and where the model is likely to fail."
    },
    {
      "heading": "3.2 Rule-based Explanation",
      "text": "What are explanations of a machine learning model? In existing literature, explanations can take different forms. One widely accepted form of explanation in the machine learning community is the gradients of the input [37], which is often used to analyze deep neural networks. Recently, Ribeiro et al. [31] and Krause et al. [17] defined an explanation of the model\u2019s prediction as a set of features that are salient for predicting an input. Explanations can also be produced via analogy, that is, explaining the model\u2019s prediction of an instance by providing the predictions of similar instances. These explanations, however, can only be used to explain the model locally for a single instance.\nIn this paper, we present a new type of explanation that utilizes rules to explain machine learning models globally (Q1). A rule-based explanation of a model\u2019s prediction Y of a set of instances X is a set of IF-THEN decision rules. For example, a model predicts that today it will rain. A human explanation might be: it will rain because my knees hurt. The underlying rule format of the explanation would be: IF knees hurt = True THEN rain = 0.9. Such explanations with implicit rules occur throughout daily life, and are analogous to the inductive reasoning process that we use every day.\nIt should be also noted that there exist different variants of rule-based models. For example, rules can be mutually-exclusive or inclusive (i.e., an instance can fire multiple rules), conjunctive (AND) or disjunctive (OR), and standard or oblique (i.e., contain composite features). Though mutually-exclusive rule sets do not require conflict resolution, the complexity of a single rule is usually much larger than an inclusive rule set. In our implementation, we use the representation of an ordered list of inclusive rules (e.g., Bayesian Rule Lists [19, 46]). When performing inference, each rule is queried in order and will only fire if all its previous rules are not satisfied. This allows fast queries and bypasses the complex conflicts resolution mechanisms."
    },
    {
      "heading": "3.3 The Pipeline",
      "text": "Our pipeline for creating rule-based visual explanations consists of the three steps (Fig. 2): 1. Rule Induction, 2. Filtering, and 3. Visualization.\nRule Induction. Given a model F that we want to explain, the first step is to extract a rule list R that can explain it. There are multiple choices of algorithms as discussed in Sect. 2.1. In this step we adopt the common pedagogical learning settings. The original model is treated as a teacher, and the student model is trained using the data \u201clabeled\u201d by the teacher. That is, we use the predictions of the teacher model as labels instead of the real labels. The algorithm is described in detail in Section 4.\nFiltering. After extracting a rule list approximation of the original model, we will have a semi-understandable explanation. The rule list is understandable in the sense that each rule is human-readable. However, the length of the list can grow too long (e.g., a few hundreds) to be practically understandable. Thus we adopt a step of filtering to obtain a more compact and informative list of rules.\nVisualization. The simplest way to present a list of rules is just to show a list of textual descriptions. However, there are a few drawbacks associated with purely textual representations. First, it is difficult to identify the importance and certainty of each extracted rule (Q2). Second, it is difficult to perform verification of the model\u2019s prediction if the length of the list is long or the number of features is large. This is because the features used in each rule may be different and not aligned [15], which results in a waste of time in aligning features in input and features used in a rule.\nAs a solution, we develop RuleMatrix, a matrix-based representation of rules, to help users understand, explore and validate the knowledge learned by the original model. The details of the filtering and visual interface are discussed in Section 5."
    },
    {
      "heading": "4 RULE INDUCTION",
      "text": "In this section, we present the algorithm for extracting rule lists from trained classifiers. The algorithm takes a trained model and a training set X as input, and produces a rule list that approximates the classifier."
    },
    {
      "heading": "4.1 The Algorithm",
      "text": "We view the task of extracting a rule list as a problem of model induction. Given a classifier F , the target of the algorithm is a rule list R that approximates model F . We define the fidelity of the approximate rule list R as its accuracy with the true labels as the output of F :\nfidelity(R)X = 1 |X | \u2211 x\u2208X [F (x) = R(x)], (1)\nwhere [F (x) = R(x)] evaluates to 1 if F (x) = R(x) and 0 otherwise. The task can be also viewed as an optimization problem, where we are maximizing the fidelity of the rule list. Unlike common machine learning problems, we have access to the original model F , which can be used as an omniscient oracle that we can ask for the labels of new data. Our algorithm highlights the use of the oracle.\nThe algorithm contains four steps (Algorithm 1). First, we model the distribution of the provided training data X . We use a joint distribution estimation that can handle both discrete and continuous features simultaneously. Second, we sample a number of data Xsample from the joint distribution. The number of samples is a customizable parameter and can be larger than the amount of original training data. Third, the original model F is used to label the sampledXsample. In the final step, we use the sampled data Xsample and the labels Ysample to train a rule list. There are a few choices [11, 22, 46] for the training algorithm.\nInput: model F , training data X , rule learning algorithm TRAIN Parameters: parameter nsample, feature set S Output: A rule list R that approximates F\n1 M \u2190 ESTIMATEDISTRIBUTION(X , S); 2 Draw samples Xsample \u2190 SAMPLE(M , nsamples); 3 Get the labels of Xsample using: Ysample \u2190 F (Xsample); 4 Rule list R\u2190 TRAIN(Xsample, Ysample); 5 return R;\nAlgorithm 1: Rule Induction\nThe distribution estimation and sampling steps are inspired by TrePan [9], a tree induction algorithm that recursively extracts a decision tree from a neural network. The sampling is mainly needed for two reasons. First, since the goal is to extract a rule list that approximates the given model, the rule list should also be able to approximate the model\u2019s behavior on input that has not been seen before. The sampling helps generate unforeseen data. Second, when the training data is limited, the sampling step creates sufficient training samples, which helps\nachieve a good fidelity for the extracted rule list. Next, we introduce the details of the algorithm.\nInput: training data X , feature set S Output: The distribution estimation M\n1 Divide the features S into discrete features Sdisc and continuous features Scon; 2 Partition X to Xdisc and Xcon according to Sdisc and Scon; /* Estimate the categorical distribution p */ 3 Initialize a counter Counter : xdisc 7\u2192 0; 4 for x(i)disc in Xdisc do 5 Counter[x\n(i) disc]\u2190 Counter[x (i) disc] + 1\n6 end 7 for x(i)disc in Counter do 8 p\nx (i) disc \u2190 Counter[x(i)disc]/|X |; 9 end\n/* Estimate conditional density f */ 10 Estimate the bandwidth matrix H from Xcon; 11 for x(i)disc in Counter do 12 f\nx (i) disc \u2190 DENSITYESTIMATION(Xcon, H); 13 end 14 return M = (p, f);\nAlgorithm 2: Estimate Distribution\nDistribution Estimation. The first step is to build a model M that estimates the distribution of the training set X = {x(i)}Ni=1 with N instances, where each x(i) \u2208 Rk is a k dimensional vector. Without losing generality, we assume the k features are mixed with d discrete features xdisc = (x1, ..., xd) and (k \u2212 d) continuous features xcon = (xd+1, ..., xk). Using Bayes\u2019 Theorem, we can write the joint distribution of the mixed discrete and continuous random variables as:\nf(x) =f(xdisc,xcon)\n=Pr(xdisc)f(xcon | xdisc). (2)\nThe first term is the probability mass function of the discrete random variables, and the second term is the conditional density function of the continuous random variables given the values of the discrete variables. Next we discuss the two terms separately.\nWe assume that the discrete features xdisc follow categorical distributions. The probability of each combination of xdisc can be estimated using its frequency in the training data (Algorithm 2, lines 3-9):\nPr(xdisc = xdisc) = p\u0302xdisc =\n\u2211N i=1[x (i) disc = xdisc]\nN , (3)\nwhere [x(i)disc = xdisc] evaluates to 1 if x (i) disc = xdisc, and 0 otherwise.\nWe use multivariate density estimation with Gaussian kernel to model continuous features xcon (Algorithm 2, line 10-13). Since we are interested in the conditional distribution, we can write the conditional density estimation as:\nf(xcon | xdisc)\n= 1 |S| \u2211 x\u2208S exp{\u2212 1 2 (xcon \u2212 xcon)TH\u22121(xcon \u2212 xcon)} (2\u03c0) c 2 |H| 12 , (4)\nwhere S = {x | xdisc = xdisc,x \u2208 X} is a subset of training data that has the same discrete values as xdisc, and c = (k \u2212 d) is the number of the continuous features. Here H is the bandwidth matrix, and also the covariance matrix for the kernel function. The problem left is how to choose the bandwidth matrix H. There are a few methods for estimating the optimal choice of H, such as smoothed cross validation and plug-in. For simplicity, we adopt Silverman\u2019s rule-of-thumb [36]:\n\u221a Hii = ( c+ 2\n4 n)\u2212 1 c+4 \u03c3i\nHij = 0, i 6= j, (5)\nTo appear in IEEE Transactions on Visualization and Computer Graphics\nwhere \u03c3i is the standard deviation of feature i. Once we have built a model of the distribution, M , we can easily create Xsample. The question left is how to choose a proper number of samples, which will be discussed in Sect. 4.2.\nRule List. In the last step, a training algorithm TRAIN is needed to learn a rule list from (Xsample,Ysample). There exist various algorithms that can construct a list of rules from training data [11,22,44,46]. Both of the algorithms proposed by Marchand and Sokolova [22] and Fawcett [11] follow a greedy construction mechanism and do not offer a good performance. In the implementation, we adopt the Scalable Bayesian Rule List (SBRL) algorithm proposed by Yang et al. [46]. This algorithm models the rule list using a Bayesian framework and allows users to specify priors related to the length of the list and the complexity of each rule. This is useful for our task, since we can have controls on the complexity of the extracted rule list. This algorithm also has the advantage that it can be more naturally extended to support multi-class classification (i.e., by switching the output distribution from binomial to multinomial), which supports a more generalizable solution. Readers can refer to the paper by Yang et al. [46] for more details.\nNote that the algorithm requires a preprocessing step to discretize the input and pre-mine a candidate rule sets for the algorithm to choose from. In our implementation, we use the minimum description length (MDL) discretization [32] to discretize continuous features, and use the FP-Growth item set mining algorithm [14] to get the candidate rule sets. Other discretization and rule mining methods can also be used."
    },
    {
      "heading": "4.2 Experiments",
      "text": "To study the effect of sample size and evaluate the performance of the proposed rule induction algorithm, we test our induction algorithm on several publicly available datasets from the UCI Machine Learning Repository [10] and a few popular models that are commonly regarded as hard to interpret.\nSampling Rate. First, we study the effect of sampling rate (i.e., number of samples / number of training data) using three datasets, Abalone, Bank Marketing and Pima Indian Diabetes (Pima). Abalone contains the physical measurements of 4177 abalones originally labeled with their rings (representing their ages). Since our current implementation only supports classification, we replace the number of rings with four simplified and balanced labels, i.e., rings < 9, 9 \u2264 rings < 12, 12 \u2264 rings < 15, and 15 < rings, with 1407, 1810, 596, and 364 instances respectively. Bank Marketing and Pima are binary classifications. All three datasets are randomly partitioned into a 75% training\nset and a 25% test set. We train a neural network with four hidden layers and 50 neurons per layer on the training set. Then we test the algorithm on the neural network with six sampling rates growing exponentially: 0.25, 0.5, 1.0, 2.0, 4.0, and 8.0. We run each setting 10 times and compute the fidelity on the test set.\nAs shown in Fig. 3, with all three datasets, the fidelity of extracted rule lists generally increases as the sampling rate grows. However, the complexity of the rule lists also increases dramatically (which is also a reason for an additional visual interface). Here there is a trade-off between the fidelity and interpretability of the extracted rule list. Considering that interpretability is our major goal, we adopt the following strategy for choosing sampling rate: start from a small sampling rate (1.0), and gradually increase the sampling rate until we get a good fidelity or the length of the rule list exceeds an acceptable threshold (e.g., 60).\nFidelity. To verify that the proposed rule induction algorithm is able to produce a good approximation of a given model, we benchmark the algorithm on a set of datasets with two different classifiers, neural networks and support vector machines. The datasets we use include: Breast Cancer Wisconsin (Diagnostics), Iris, Wine, Abalone (four-class classification), Bank Marketing, Pima Indian Diabetes and Adult.\nWe test the algorithm on neural networks with one, two, and four hidden layers, and support vector machines with nonlinear Radial Basis Function (RBF) kernel. We use the implementation of these models in the scikit-learn package [25]. We use a sampling rate of 2.0 for the Adult dataset, and a sampling rate of 4.0 for the rest. As shown in Table 1, the rule induction algorithm can generate rule lists that approximate a model with acceptable fidelity on the selected datasets. The fidelity is over 90% on most datasets except for Pima and Abalone.\nSpeed. The time for creating a list of 40 rules from 7,000 samples with 20 features can take up to 3 minutes on a PC (the time varies under different parameters). The estimation and sampling step take less than one second, and the major bottleneck lies in the FP-Growth (less than 10 seconds) and SBRL (more than 2 minutes) algorithms. We restrict the discussion of this issue in this paper due to page limits. The material necessary for reproduce the results is available at http: //rulematrix.github.io."
    },
    {
      "heading": "5 RULEMATRIX: THE VISUAL INTERFACE",
      "text": "This section presents the design and implementation of the visual interface for helping users understand, navigate and inspect the learned knowledge of classifiers. As shown in Fig. 1, the interface contains a control panel (A), a main visualization (B), a data filter panel (C) and a data table (D). In this section, we mainly present the main visualization, RuleMatrix, and the interactions supported by the other views."
    },
    {
      "heading": "5.1 Visualization Design",
      "text": "RuleMatrix (Fig. 4) consists of three visual components: the rule matrix, the data flow, and the support view. The rule matrix visualizes the content of a rule list in a matrix-based design. The data flow shows how data flows through the list using a Sankey diagram. The support view supports the understanding and analysis of the original model that we aim to explain."
    },
    {
      "heading": "5.1.1 Rule Matrix",
      "text": "The major visual component of the interface is the matrix-based visualization of rules. A decision rule is a logical statement consisting of two parts: the antecedent (IF) and the consequent (THEN). Here we restrict the antecedent to be a conjunction (AND) of clauses, where each clause is a condition on an input feature (e.g., 3 < x1 AND x2 < 4). This restriction eases users\u2019 cognitive burden of discriminating different logical operations. The output of each rule is a probability distribution over possible classes, representing the probability of an instance satisfying the antecedent belongs to each class. The simplest way to present a rule is to write it down as a logical expression, which is ubiquitous in programing languages. However, we found textual representations difficult to navigate when the length of the list is too large. The problem with textual representations is that the input features are not presented in the same order in each rule. Thus, it is difficult for users to search a rule with certain condition or compare the conditions used in different rules. This problem has also been identified by Huysmans et al. [15],\nTo address this issue and help users understand and navigate the rule list (Q1), we present the rules in a matrix format. As shown in Fig. 4B, each row in the matrix represents the antecedent of a decision rule, and each column represents an input feature. If the antecedent of a decision rule i contains a clause using feature xj , then a compact representation (Fig. 4- 1\u00a9) of the clause is shown in the corresponding cell (i, j). In this layout, the order of the features is fixed, which helps users visually search and compare rules by features. The length of the bar underneath a feature name encodes the frequency with which the feature occurs in the decision rules. The features are also sorted according to their importance scores, which is computed by the number of instances that a feature has been used to discriminate. The advantage of the matrix representation is that it allows users to verify and compare different rules quickly. This also allows easier verification and evaluation of the model\u2019s predictions (Q3).\nVisualizing Conditions. In the antecedent of rule i, a clause that uses feature j (e.g., 0 \u2264 xj < 3) is visualized as a gray and translucent box in cell (i, j), where the covered range represents the interval in the clause (i.e., [0, 3)). In each cell (i, j), a compact view of the data distribution of feature j is also presented (inspired by the idea of sparklines [40]). For continuous features, the distributions are visu-\nalized as histograms. For discrete features, bar charts are used. The part of data that satisfies the clause is also highlighted with a higher opacity. This combination of the compact view of data distribution and the range constraint helps users quickly grasp the properties of different clauses in a rule (Q1), i.e., the tightness or width of the interval and the number of instances that satisfy the clause.\nVisualizing Outputs. As discussed above, the output of a rule is a probability distribution. At the end of each row, we present the output of the rule as a colored number, with color representing the output label of the rule, and the number showing the probability of the label. A vertically stacked bar is positioned next to the number to show the detailed probability of each label. Using this design, users are able to quickly identify the output label of the rule by the color, and learn the actual probability of the label from the number."
    },
    {
      "heading": "5.1.2 Data Flow",
      "text": "To provide users with an overall sense of how the input data is classified by different rules, a waterfall-like Sankey diagram (Fig. 4A) is presented to the left of the rule matrix. The main vertical flow represents the data that remains unclassified. Each time the main flow \u201cencounters\u201d a rule (represented by a horizontal bar), a horizontal flow representing the data satisfying the rule forks from the main vertical flow. The widths of the flows represent the quantities of the data. The colors encode the labels of the data. That is, if a flow contains data with multiple labels, the flow is divided into multiple parallel sub-flows, whose widths are proportional to the quantities of different labels. The data flow helps the user maintain a proper mental model of the ordered decision rule list. The rules are ordered, and the success of a rule has the implication that previous rules are not satisfied. The user can identify the amount of data satisfying a rule through the width of the flow, which helps the user decide to trust or reject the rule (Q2). The design of the data flow is inspired by the node-link layout used in BaobabView [42]."
    },
    {
      "heading": "5.1.3 Support View",
      "text": "The support view is designed to support the understanding and analysis of the performance of the original model. Note that there are two types of errors that we are interested in: the error between the rule and the model (fidelity), and the error between the model and the real data (accuracy). When the error between a rule and the model is\nTo appear in IEEE Transactions on Visualization and Computer Graphics\nhigh, users should be notified that the rule may not be a well-extracted \u201cknowledge\u201d. When the error between the original model and the real data is high, the users should be notified that the model\u2019s prediction should not be fully trusted (Q4). In the support view, we provide for each rule a set of two performance visualizations (Fig. 4C), fidelity and evidence to help users analyze these two types of errors.\nFidelity. We use a simple glyph that contains a number (0 to 100) to present the fidelity (Equation 1) of the rule on the subset of data satisfying the rule. The value of fidelity represents how accurately the rule represents the original model on this subset. The higher the fidelity, the more reliable the rule is in representing the original model. The number is circled by an arc, whose angle also encodes the number. As shown in Fig. 4- 2\u00a9, the glyph can be colored green (high), yellow (medium), red (low) according to the level of fidelity. In the current implementation, the fidelity levels are set to above 80% (high), 50% (medium) to 80%, and below 50% (low), respectively.\nEvidence. The second performance visualization shows the evidence of the original model on the real data (users can switch between training or test set). To support comprehensive analysis of the error distribution, we adopt a compact and simplified variant of Squares [30]. As shown in Design 1 in Fig. 4- 3\u00a9, we use horizontally stacked boxes to present the predictions of the model. The color encodes the predicted class by the original model. The width of a box encodes the amount of data with a certain type of prediction. We use striped boxes to represent erroneous predictions. That is, a blue striped box ( ) represents data that is wrongly classified as class blue and has real labels different from class blue. During the development of this interface, we have experimented with an alternative design which had the same color coding, as shown in Design 2 in Fig. 4- 3\u00a9. In this alternative design, the data is divided into horizontally stacked boxes according to the true labels. Then we partition each box vertically into two parts: the upper one representing correct predictions and the lower one representing the wrong predictions (striped boxes). The lower part is further partitioned into multiple parts according to the predicted labels. However, during our informal pilot studies with two graduate students, the Design 2 was found to be \u201cconfusing\u201d and \u201cdistracting\u201d. Though Design 1 fails to present the real labels of the wrong predictions, it is more concise and can be directly used to answer whether a model is likely to fail (Q4).\nThe advantage of the compact performance visualization is that it presents an intuitive error visualization within a small space. We can easily identify the amount of instances classified as a label or quantify the mistakes by searching for the boxes with the corresponding coding."
    },
    {
      "heading": "5.2 Interactions",
      "text": "RuleMatrix supports three types of interactions: filtering the rules, which is used to reduce cognitive burden by reducing the number of rules to show; filtering the data, which is used to explore the relation between the data and the rules; and details on demand."
    },
    {
      "heading": "5.2.1 Filtering the Rules",
      "text": "The filtering of rules helps relieve the scalability issue and reduce the cognitive load when the extracted rule list is too long. This occurs when we have a complex model (e.g., a neural net with multiple layers, or an SVM with nonlinear kernel), or a complex data set. In order to learn a rule list that well approximates the model, the complexity of the rule list inevitably grows. In our implementation, we provide two types of filters: filter by support and filter by confidence. The former filters the rules that have little support, which are seldom fired and are not salient. The latter filters the rules that have low confidence, which are not significant in discriminating different classes. In our implementation, filtered rules are grouped into collapsed \u201crules\u201d so that users can keep track of them. Users can also expand the collapsed rules to see them in full details. By adjusting rule filters, users are allowed to explore a list of over 100 rules with no major cognitive burden."
    },
    {
      "heading": "5.2.2 Filtering the Data",
      "text": "The data filtering function is needed to support two scenarios. First, data filtering allows users to apply the divide and conquer strategy to understand the model\u2019s behavior, i.e., only focus on the model\u2019s\nbehavior on the data one is interested in. Second, by filtering, users can identify the data entries in the data table (Fig. 1D) that support specific rules. This boosts users\u2019 trust in both the system and the model. During our experiments, we found that data filters can greatly reduce the number of rules shown when combined with rule filters."
    },
    {
      "heading": "5.2.3 Details on Demand",
      "text": "To provide a clean and concise interface, we hide the details that users can view on demand. Users can request details in two ways: interacting with the RuleMatrix directly or modifying the settings in the control panel. In the RuleMatrix, users can check the actual text description of a clause by hovering on the corresponding cell. To view the details about the data distribution, users can click on a cell, which expand the cell and show a stream plot (continuous feature) or a stacked bar charts (categorical feature) of the distribution (Fig. 4B). The choice of stream plot for continuous features is due to its ability in preventing color discontinuities [42]. A vertical ruler that follows the mouse is displayed to help align and compare the intervals of the clauses using the same feature across multiple rules. Users can see the actual amount of data by hovering over the evidence bars or certain parts of the data flow. Users can view the conditional distribution or hide the striped error boxes by modifying the settings in the control panel. Here the conditional distribution of feature xj at rule i denotes the distribution given that all previous rules are not satisfied, that is, the distribution of the data that is left unclassified until rule i.\nThe rule filtering functions are provided in the control panel (Fig. 1A), and the data filtering functions are provided in the data filter (Fig. 1C). Users are also allowed to customize an input and request the system to present the prediction of the original model and highlight the satisfied rule."
    },
    {
      "heading": "6 EVALUATION",
      "text": "We present a usage scenario, a use case, and a user study to demonstrate how our method effectively helps users understand the behavior of a classifier."
    },
    {
      "heading": "6.1 Usage Scenario: Understanding a Cancer Classifier",
      "text": "We first present a hypothetical scenario to show how RuleMatrix helps people understand the knowledge learned by a machine learning model.\nMary, a medical student is learning about breast cancer and is interested in identifying cancer cells by the features measured from biopsy specimens. She is also eager to know whether the popular machine learning algorithms can learn to classify cancer cells accurately. She downloads a pre-trained neural network and the Breast Cancer Wisconsin dataset from the Internet. The dataset contains cytological characteristics of 699 breast fine-needle aspirates. Each of the cytological characteristics are graded from 1 to 10 (lower is closer to begin) at the time of sample collection. The accuracies of the model on training and test set are 97.3% and 97.1% respectively. She want to know what knowledge the model has learned (Q1).\nUnderstanding the rules. Mary uses our pipeline and extracts a list of 12 rules from the neural network. The visualization is presented to Mary. She quickly goes through the list and notices that rule 6 to rule 12 have little support from the training data (Q2). Then she adjust the minimum evidence in the rule filter (Fig. 1A) to 0.014 to collapse the last 7 rules (Fig. 5). She then finds that the first rule outputs malignant with a high probability (0.99) and a high fidelity (0.99). She looks into the rule matrix and learns that if the marginal adhesion score is larger than 5, the model will very likely predict malignancy. This aligns with her knowledge that the loss of adhesion is a strong sign of cancer cells. Then she checks rule 3, which has the largest support from the dataset. The rule shows that if the bland chromatin (the texture of nucleus) is smaller or equal than 1, the cell should be benign. She finds this rule interesting since it indicates that one can quickly identify benign cells in the examination by checking if the nucleus is coarse."
    },
    {
      "heading": "6.2 Use Case: Improving Diabetes Classification",
      "text": "In this use case, we the Pima Indian Diabetes Dataset (PIDD) [38] to demonstrate how RuleMatrix can lead to performance improvements. The dataset contains diagnostic measurements of 768 female patients aged from 21 to 81, of Pima Indian heritage. The task is to classify negative patients (healthy) and positive patients (has diabetes). Each data instance contains eight features: the number of previous pregnancies, plasma glucose, blood pressure, skin thickness, insulin, body mass index (BMI), and diabetes pedigree function (DPF). DPF is a function measuring a patient\u2019s probability of getting diabetes based on the history of the patient\u2019s ancestors. The dataset is randomly partitioned into 75% training set and 25% test set. The distribution of the labels in the training set and test set are 366 negatives / 210 positives and 134 negatives / 58 positives respectively.\nIn the beginning, we trained a neural network of 2 layers with 20 neurons in each layer. The l-2 normalization factor was determined as 1.0 via 3-fold cross-validations. We ran the training 10 times and received an average accuracy of 72.4% on the test data. The best neural network had an accuracy of 74.0% on the test set. We ran the proposed rule-based explanation pipeline and extracted a list of 22 decision rules from a trained network. The rule list is visualized with the training data and a rule filter of minimum evidence of 0.02 (Fig. 6A). From the header \u201cevidence\u201d, we can see that the neural network achieves an overall accuracy of 79% on the training set.\nUnderstanding the Rules (Q1, Q2). Then we navigated the extracted rules using the RuleMatrix with the training set. We noticed that there was no dominant rules with large supports, except for rule 4 and the last default rule, which have relatively longer bars in the \u201cevidence\u201d column, indicating a larger support. This reflects that the dataset is in a difficult domain and it is not easy to accurately predict whether one has diabetes or not. Rule 1 (Fig. 6- 1\u00a9) has only one condition, 176 < plasma glucose, which means that a patient with high plasma glucose is very likely to have diabetes. This agrees with our common knowledge in diabetes. Then we noticed that the outputs of rules 2 to 5 were all negative with probabilities above 0.98. Thanks to the aligned layout of features, we derived an overall sense that the patients younger than 32 (Fig. 6- 2\u00a9) and a BMI less than 36.5 are not likely to have diabetes. After going through the rest of the list, we concluded that patients with high plasma glucose and high BMI are more likely to have diabetes, and young patients are less likely to have diabetes in general.\nUnderstanding the Errors (Q4). After navigating the rules, we were mostly interested in the type of patients that have diabetes but are wrongly classified as negative by the neural network. The false negative errors are undesirable in this domain since they may delay the treatment of a real patient and cause higher risks. Based on our findings concluded from rules 2 to 5, we decided to focus on the patients older than 32, that is, those with higher risk. We also filtered the patients with low or high plasma glucose (lower than 108 or higher than 137), because most of them are correctly classified as negative or positive by the model. As a result of the filtering, the accuracy of the model on the remaining data (74 instances) immediately dropped to 62%. From the resulting rules, we then further filtered patients with a BMI lower than 27, who are unlikely to have diabetes, and the patients with a DPF higher than 1.18, who are very likely to have the disease. After the filtering (Fig. 6B), the accuracy of the model on the resulting subset of 62 patients dropped to only 56%. From Fig. 6C, we found a large portion of blue striped boxes ( ), denoting patients that have diabetes but were wrongly classified as healthy. This validated our suspicion that the patients with no obvious indicators are difficult to classify.\nImproving the Performance. Based on the understanding of the error, a simple idea appeared to be worth trying: can we improve the accuracy of the model by oversampling the difficult subset? We experimented by oversampling this subset by half the amount to get 31 new training data, and trained new neural networks with the same\nTo appear in IEEE Transactions on Visualization and Computer Graphics\nhyper-parameters. To determine whether the change led to an actual improvement, we ran the training and sampling 10 times. The mean accuracy of 10 runs reached 75.5% on the test set, with a standard deviation of 2.1%. The best model had a performance of 78.6%, which was significantly better than the original best model (74.0%)."
    },
    {
      "heading": "6.3 User Study",
      "text": "We conducted a quantitative experiment to evaluate the effectiveness of RuleMatrix in helping users understand the behavior of machine learning models. The main goal of the experiment is to investigate whether users can understand the interactive matrix-based representation of rules, and whether users can understand the behavior of a given model via the rule-based explanations. We asked participants to perform relevant tasks to benchmark the effectiveness of the proposed interface, and asked for subjective feedbacks to understand users\u2019 preference and directions for improvements.\nStudy Design. We recruited nine participants, ages 22 to 30. Six were current graduate students majoring in computer science, three had experience in research projects related to machine learning, and none of them had prior experiences in model induction. The experiments were conducted using a 23\u201d monitor.\nThe study was organized into three steps. First, each participant was presented with a 15 minutes tutorial and was given 5 minutes to navigate and explore the interface. Second, participants were asked to perform a list of tasks using RuleMatrix. Finally, participants were asked to answer five subjective questions related to the general usability of the interface and suggestions for improvements. We used the Iris dataset and an SVM as the to-be-explained model during the tutorial. In the formal study, we used the Pima Indian Diabetes dataset, and used RuleMatrix to explain a neural network with two hidden layers with 20 neurons per layer. The extracted rule list contained 20 rules, each containing a conjunction of 1, 2, or 3 clauses).\nTasks. Six tasks (Table 2) were created to validate participants\u2019 ability to answer the questions (Q1 - Q4) using RuleMatrix. For each task, we created two different questions with the same format (e.g., multiple-choice questions). That is, each participant was asked to perform 12 tasks. Questions of T1 to T5 were multiple-choice questions with one correct answer and four choices. T6(a) was also multiplechoice question while T6(b) asked the participants to enter a number.\nResults. The average time that the participants took to complete all the 12 tasks in the formal study was 14\u2019 43\u201d (std: 2\u2019 26\u201d). Accuracy of the performed tasks is summarized in Table 2. All the participants performed the required tasks fluently and correctly most of the time. This suggests validation of the basic usability of our method. However, we observed that participants took extra time in completing T2, which required the search and comparisons of multiple rules and multiple features. Three also complained that it was easy to get the wrong message from the textual representations provided in the choices in T1 and T2 (i.e., mistake 29 < x from x < 29), and they had to double check to make sure that the clauses they identified in the visualization indeed matched the texts. We examined the answer sheets and found\nthe errors of T1 are all of this type. This affirmed to us that text is not as intuitive as graphics in representing intervals in our context.\nFeedback. We gathered feedback through subjective questionnaires after the formal study. Most participants felt that the supported interactions (expand, highlight and filter) are very \u201cuseful and intuitive\u201d. The detailed information provided by the data flow and support view was also regarded as \u201chelpful and just what they need\u201d. One participant liked how he could \u201clocate my hypotheses in the rules and understand how the model reacts, whether it is right or wrong, and how much observations in the dataset supports the hypotheses\u201d. However, one participant had trouble understanding that there is only conjunctive relation between multiple clauses in a rule. Two participants suggested that a rule searching function would also be useful in validating hypotheses."
    },
    {
      "heading": "7 DISCUSSION AND CONCLUSIONS",
      "text": "In this work, we presented a technique for understanding classification models using rule-based explanations. We preliminarily validated the effectiveness of the rule induction algorithm on a set of benchmark datasets, and the effectiveness of the visual interface, RuleMatrix, through two use cases and a user study.\nPotential Usage Scenarios. We anticipate the application of our method in domains where explainable intelligence is needed. Doctors can better utilize machine learning techniques for diagnosis and treatments with clear explanations. Banks can use efficient automatic credit approval systems while still being able to provide explanations to the applicants. Data scientists can better explain their findings when they need to present the results to no-experts.\nScalability of the Visualization. Though the current implementation of the RuleMatrix can visualize rule lists with over 100 rules with over 30 features, the readability and understandability have only been validated on rule lists with less than 60 rules and 20 features. It is unclear whether users can still get an overall understanding of the model from such a complex list of rules. In addition, we used a qualitative color scheme to encode different classes. Though the effectiveness is limited to datasets with a limit number of classes, we assume that the method will be effective in most cases, since most classification tasks have fewer than 10 classes. It is also interesting to see if the proposed interface can be extended to support regression models by changing the qualitative color scheme to sequential color schemes.\nScalability of the Rule Induction Method. An intrinsic limitation of the rule induction algorithm results from the trade-off between the fidelity and complexity (interpretability) of the generated rule list. Depending on the complexity of the model and the domain, the algorithm would require a list containing hundreds of rules to approximate the model with an acceptable fidelity. The interpretability of rules also depends on the meaningfulness of the input features. This also limits the usage of our method in domains such as image classification or speech recognition. Another limitation is the current unavailability of efficient learning algorithms for rule lists. The SBRL algorithm takes about 30 minutes to generate a rule list from 200,000 samples and 14 features on server with 2.2GHz Intel Xeon. Its performance does not generalize well to datasets with an arbitrary number of classes.\nFuture Work. One limitation of the presented work is that the method has not been fully validated with real experts in specific domains (e.g., health care). We expect to specialize the proposed method to meet the needs of specific domain problems (e.g., cancer diagnosis, or credit approvals) based on future collaborations with domain experts. Another interesting direction would be to systematically study the advantages and disadvantages of different knowledge representations (e.g., decision trees and rule sets) when considering human understandability. In other words, would people feel more comfortable with hierarchical representations (trees) or flat representations (lists) under different scenarios (e.g., verifying a prediction or understanding a complete model)? We regard this work as a preliminary and exploratory step towards explainable machine learning and plan to further extend and validate the idea of interpretability via inductive rules."
    }
  ],
  "title": "RuleMatrix: Visualizing and Understanding Classifiers with Rules",
  "year": 2018
}
