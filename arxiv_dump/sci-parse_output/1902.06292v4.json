{"abstractText": "We propose a novel inherently interpretable machine learning method that bases decisions on few relevant examples that we call prototypes. Our method, ProtoAttend, can be integrated into a wide range of neural network architectures including pre-trained models. It utilizes an attention mechanism that relates the encoded representations to samples in order to determine prototypes. The resulting model outperforms state of the art in three high impact problems without sacrificing accuracy of the original model: (1) it enables high-quality interpretability that outputs samples most relevant to the decision-making (i.e. a sample-based interpretability method); (2) it achieves state of the art confidence estimation by quantifying the mismatch across prototype labels; and (3) it obtains state of the art in distribution mismatch detection. All this can be achieved with minimal additional test time and a practically viable training time computational cost.", "authors": [{"affiliations": [], "name": "Sercan \u00d6. Ar\u0131k"}, {"affiliations": [], "name": "Tomas Pfister"}], "id": "SP:28b73eeb6e89df19461d218e3bf88157dbdc79b2", "references": [{"authors": ["Dzmitry Bahdanau", "Kyunghyun Cho", "Yoshua Bengio"], "title": "Neural machine translation by jointly learning to align and translate", "venue": "In ICLR,", "year": 2015}, {"authors": ["Jacob Bien", "Robert Tibshirani"], "title": "Prototype selection for interpretable classification", "year": 2012}, {"authors": ["Chaofan Chen", "Oscar Li", "Alina Barnett", "Jonathan Su", "Cynthia Rudin"], "title": "This looks like that: deep learning for interpretable image recognition", "year": 2018}, {"authors": ["Alexis Conneau", "Holger Schwenk", "Lo\u0131\u0308c Barrault", "Yann LeCun"], "title": "Very deep convolutional networks for natural language processing", "year": 2016}, {"authors": ["Maurizio Corbetta", "Gordon L. Shulman"], "title": "Control of goal-directed and stimulus-driven attention in the brain", "venue": "Nature Reviews Neuroscience,", "year": 2002}, {"authors": ["Yin Cui", "Feng Zhou", "Yuanqing Lin", "Serge J. Belongie"], "title": "Fine-grained categorization and dataset bootstrapping using deep metric learning with humans in the loop", "year": 2016}, {"authors": ["Terrance DeVries", "Graham W. Taylor"], "title": "Learning Confidence for Out-of-Distribution", "venue": "Detection in Neural Networks", "year": 2018}, {"authors": ["Dumitru Erhan", "Yoshua Bengio", "Aaron Courville", "Pascal Vincent"], "title": "Visualizing higher-layer features of a deep network", "venue": "In Technical report,", "year": 2009}, {"authors": ["H A Haenssle", "C Fink", "R Schneiderbauer", "F Toberer", "T Buhl"], "title": "Man against machine: diagnostic performance of a deep learning convolutional neural network for dermoscopic melanoma recognition in comparison to 58 dermatologists", "venue": "Annals of Oncology,", "year": 2018}, {"authors": ["Kaiming He", "Xiangyu Zhang", "Shaoqing Ren", "Jian Sun"], "title": "Deep residual learning for image recognition", "year": 2016}, {"authors": ["Dan Hendrycks", "Kevin Gimpel"], "title": "A baseline for detecting misclassified and out-of-distribution examples in neural networks", "year": 2016}, {"authors": ["Sepp Hochreiter", "Jrgen Schmidhuber"], "title": "Long short-term memory", "venue": "Neural Computation,", "year": 1997}, {"authors": ["Elad Hoffer", "Nir Ailon"], "title": "Deep metric learning using triplet network", "year": 2014}, {"authors": ["Anthony F. Jerant", "Jennifer T. Johnson", "Catherine Demastes Sheridan", "Timothy J. Caffrey"], "title": "Early detection and treatment of skin cancer", "venue": "Am Fam Physician,", "year": 2000}, {"authors": ["Heinrich Jiang", "Been Kim", "Maya R. Gupta"], "title": "To trust or not to trust a classifier", "venue": "In NIPS,", "year": 2018}, {"authors": ["Alex Kendall", "Yarin Gal"], "title": "What Uncertainties Do We Need in Bayesian Deep Learning for Computer Vision", "year": 2017}, {"authors": ["Alex Kendall", "Yarin Gal"], "title": "What uncertainties do we need in bayesian deep learning for computer vision", "venue": "In NIPS,", "year": 2017}, {"authors": ["B. Kim", "M. Wattenberg", "J. Gilmer", "C. Cai", "J. Wexler", "F. Viegas", "R. Sayres"], "title": "Interpretability Beyond Feature Attribution: Quantitative Testing with Concept Activation Vectors (TCAV)", "year": 2018}, {"authors": ["Wonsik Kim", "Bhavya Goyal", "Kunal Chawla", "Jungmin Lee", "Keunjoo Kwon"], "title": "Attention-based ensemble for deep metric learning", "venue": "In ECCV,", "year": 2018}, {"authors": ["Diederik P. Kingma", "Jimmy Ba"], "title": "Adam: A method for stochastic optimization", "venue": "In ICLR,", "year": 2014}, {"authors": ["Pang Wei Koh", "Percy Liang"], "title": "Understanding Black-box Predictions via Influence Functions", "venue": "In ICML,", "year": 2017}, {"authors": ["Balaji Lakshminarayanan", "Alexander Pritzel", "Charles Blundell"], "title": "Simple and scalable predictive uncertainty estimation using deep ensembles", "venue": "In NIPS", "year": 2017}, {"authors": ["Oscar Li", "Hao Liu", "Chaofan Chen", "Cynthia Rudin"], "title": "Deep learning for case-based reasoning through prototypes: A neural network that explains its predictions", "venue": "In AAAI,", "year": 2018}, {"authors": ["Andr\u00e9 F.T. Martins", "Ram\u00f3n Fern\u00e1ndez Astudillo"], "title": "From softmax to sparsemax: A sparse model of attention and multi-label classification", "venue": "In MLR,", "year": 2016}, {"authors": ["G.A. Miller"], "title": "The magical number seven, plus or minus 2: Some limits on our capacity for processing information", "venue": "Psychological review, 63:81\u201397,", "year": 1956}, {"authors": ["Nicolas Papernot", "Patrick D. McDaniel"], "title": "Deep k-nearest neighbors: Towards confident, interpretable and robust deep learning", "year": 2018}, {"authors": ["Mengye Ren", "Renjie Liao", "Ethan Fetaya", "Richard S. Zemel"], "title": "Incremental few-shot learning with attention attractor networks", "year": 2018}, {"authors": ["Sara Sabour", "Nicholas Frosst", "Geoffrey E. Hinton"], "title": "Dynamic routing between capsules", "venue": "In NIPS,", "year": 2017}, {"authors": ["Devendra Singh Sachan", "Petuum"], "title": "Revisiting lstm networks for semi-supervised text classification via mixed objective function", "venue": "In KDD,", "year": 2018}, {"authors": ["Karen Simonyan", "Andrea Vedaldi", "Andrew Zisserman"], "title": "Deep inside convolutional networks: Visualising image classification models and saliency maps", "year": 2013}, {"authors": ["Chawin Sitawarin", "David A. Wagner"], "title": "On the robustness of deep k-nearest neighbors", "year": 2019}, {"authors": ["Jake Snell", "Kevin Swersky", "Richard S. Zemel"], "title": "Prototypical networks for few-shot learning", "venue": "In NIPS,", "year": 2017}, {"authors": ["Kihyuk Sohn"], "title": "Improved deep metric learning with multi-class n-pair loss objective", "venue": "In NIPS", "year": 2016}, {"authors": ["Ashish Vaswani", "Noam Shazeer", "Niki Parmar", "Jakob Uszkoreit", "Llion Jones"], "title": "Attention is all you need", "year": 2017}, {"authors": ["Oriol Vinyals", "Charles Blundell", "Timothy P. Lillicrap", "Koray Kavukcuoglu", "Daan Wierstra"], "title": "Matching networks for one shot learning", "venue": "In NIPS,", "year": 2016}, {"authors": ["Li Wan", "Matthew Zeiler", "Sixin Zhang", "Yann Le Cun", "Rob Fergus"], "title": "Regularization of neural networks using dropconnect", "venue": "In ICML,", "year": 2013}, {"authors": ["Chih-Kuan Yeh", "Joon Sik Kim", "Ian En-Hsu Yen", "Pradeep Ravikumar"], "title": "Representer point selection for explaining deep neural networks", "year": 2018}, {"authors": ["Matthew D. Zeiler", "Rob Fergus"], "title": "Visualizing and understanding convolutional networks", "year": 2013}, {"authors": ["Quanshi Zhang", "Ying Nian Wu", "Song Chun Zhu"], "title": "Interpretable convolutional neural networks", "year": 2018}], "sections": [{"heading": "1 INTRODUCTION", "text": "Deep neural networks have been pushing the frontiers of artificial intelligence (AI) by yielding excellent performance in numerous tasks, from understanding images (He et al., 2016) to text (Conneau et al., 2016). Yet, high performance is not always a sufficient factor - as some real-world deployment scenarios might necessitate that an ideal AI system is \u2018interpretable\u2019, such that it builds trust by explaining rationales behind decisions, allow detection of common failure cases and biases, and refrains from making decisions without sufficient confidence. In their conventional form, deep neural networks are considered as black-box models \u2013 they are controlled by complex nonlinear interactions between many parameters that are difficult to understand. There are numerous approaches, e.g. (Kim et al., 2018; Erhan et al., 2009; Zeiler & Fergus, 2013; Simonyan et al., 2013), that bring post-hoc explainability of decisions to already-trained models. Yet, these have the fundamental limitation that the models are not designed for interpretability. There are also approaches on the redesign of neural networks towards making them inherently-interpretable, as in this paper. Some notable ones include sequential attention (Bahdanau et al., 2015), capsule networks (Sabour et al., 2017), and interpretable convolutional filters (Zhang et al., 2018).\nWe focus on inherently-interpretable deep neural network modeling with the foundations of prototypical learning. Prototypical learning decomposes decision making into known samples (see Fig. 1), referred here as prototypes. We base our method on the principle that prototypes should constitute a minimal subset of samples with high interpretable value that can serve as a distillation or condensed view of a dataset (Bien & Tibshirani, 2012). Given that the number of objects a human can interpret is limited (Miller, 1956), outputting few prototypes can be an effective approach for humans to understand the AI model behavior. In addition to such interpretability, prototypical learning: (1) provides an efficient confidence metric by measuring mismatches in prototype labels, allowing performance to be improved by refraining from making predictions in the absence of sufficient confidence, (2) helps detect deviations in the test distribution by measuring mismatches in prototype labels that represent the support of the training dataset, and (3) enables performance in the high label noise regime to be improved by controlling the number of selected prototypes. Given these motivations, prototypes should be controllable in number, and should be perceptually relevant to the input in explaining the decision making task. Prototype selection in its naive form is computationally\nar X\niv :1\n90 2.\n06 29\n2v 4\n[ cs\n.L G\n] 2\n6 Se\np 20\n19\nexpensive and perceptually challenging (Bien & Tibshirani, 2012). We design ProtoAttend to address this problem in an efficient way. Our contributions can be summarized as follows:\n1. We propose a novel method, ProtoAttend, for selecting input-dependent prototypes based on an attention mechanism between the input and prototype candidates. ProtoAttend is model-agnostic and can even be integrated with pre-trained models. 2. ProtoAttend allows interpreting the contribution of each prototype via the attention outputs. 3. For a \u2018condensed view\u2019, we demonstrate that sparsity in weights can be efficiently imposed via\nthe choice of the attention normalization and additional regularization. 4. On image, text and tabular data, we demonstrate the four key benefits of ProtoAttend: interpretabil-\nity, confidence control, diagnosis of distribution mismatch, and robustness against label noise. ProtoAttend yields superior quality for sample-based interpretability, better-calibrated confidence scoring, and more sensitive out-of-distribution detection compared to alternative approaches. 5. ProtoAttend enables all these benefits via the same architecture and method, while maintaining comparable overall accuracy."}, {"heading": "2 RELATED WORK", "text": "Prototypical learning: The principles of ProtoAttend are inspired by (Bien & Tibshirani, 2012). They formulate prototype selection as an integer program and solve it using a greedy approach with linear program relaxation. It seems unclear whether such approaches can be efficiently adopted to deep learning. (Chen et al., 2018) and (Li et al., 2018) introduce a prototype layer for interpretability by replacing the conventional inner product with a distance computation for perceptual similarity. In contrast, our method uses an attention mechanism to quantify perceptual similarity and can choose input-dependent prototypes from a large-scale candidate database. (Yeh et al., 2018) decomposes the prediction into a linear combination of activations of training points for interpretability using representer values. The linear decomposition idea also exists in ProtoAttend, but the weights are learned via an attention mechanism and sparsity is encouraged in the decomposition. In (Koh & Liang, 2017), the training points that are the most responsible for a given prediction are identified using influence functions via oracle access to gradients and Hessian-vector products.\nMetric learning: Metric learning aims to find an embedding representation of the data where similar data points are close and dissimilar data pointers are far from each other. ProtoAttend is motivated by efficient learning of such an embedding space which can be used to decompose decisions. Metric learning for deep neural networks is typically based on modifications to the objective function, such as using triplet loss and N-pair loss (Sohn, 2016; Cui et al., 2016; Hoffer & Ailon, 2014). These yield perceptually meaningful embedding spaces yet typically require a large subset of nearest neighbors to avoid degradation in performance (Cui et al., 2016). (Kim et al., 2018) proposes a deep metric learning framework which employs an attention-based ensemble with a divergence loss so that each learner can attend to different parts of the object. Our method has metric learning capabilities like relating similar data points, but also performs well on the ultimate supervised learning task.\nAttention-based few-shot learning: Some of our inspirations are based on recent advances in attention-based few-shot learning. In (Vinyals et al., 2016), an attention mechanism is used to relate an example with candidate examples from a support set using a weighted nearest-neighbor classifier applied within an embedding space. In (Ren et al., 2018), incremental few-shot learning is implemented using an attention attractor network on the encoded and support sets. In (Snell et al., 2017), a non-linear mapping is learned to determine the prototype of a class as the mean of its support set in the embedding space. During training, the support set is randomly sampled to mimic the inference task. Overall, the attention mechanism in our method follows related principles but fundamentally differs in that few-shot learning aims for generalization to unseen classes whereas the goal of our method is robust and interpretable learning for seen classes.\nUncertainty and confidence estimation: ProtoAttend takes a novel perspective on the perennial problem of quantifying how much deep neural networks\u2019 predictions can be trusted. Common approaches are based on using the scores from the prediction model, such as the probabilities from the softmax layer of a neural network, yet it has been shown that the raw confidence values are typically poorly calibrated (Guo et al., 2017). Ensemble of models (Lakshminarayanan et al., 2017) is one of the simplest and most efficient approaches, but significantly increases complexity and decreased interpretability. In (Papernot & McDaniel, 2018), the intermediate representations of the network are used to define a distance metric, and a confidence metric is proposed based on the conformity of the neighbors. (Jiang et al., 2018), proposes a confidence metric based on the agreement between the classifier and a modified nearest-neighbor classifier on the test sample. In (DeVries & Taylor, 2018), direct inference of confidence output is considered with a modified loss. Another direction of uncertainty and confidence estimation is Bayesian neural networks that return a distribution over the outputs (Kendall & Gal, 2017b) (Mullachery et al., 2018) (Kendall & Gal, 2017a)."}, {"heading": "3 PROTOATTEND: ATTENTION-BASED PROTOTYPICAL LEARNING", "text": "Consider a training set with labels, {xi, yi}. Conventional supervised learning aims to learn a model s(xi;S) that minimizes a predefined loss 1/B \u00b7 \u2211B i=1 L(yi, y\u0302i = s(xi;S))\n1 at each iteration, where B is the batch size for training. Our goal is to impose that decision making should be based on only a small number of training examples, i.e. prototypes, such that their linear superposition in an embedding space can yield the overall decision and the superposition weights correspond to their importance. Towards this goal, we propose defining a solutions to prototypical learning with the following six principles:\ni. vi = f(xi; \u03b8) encodes all relevant information of xi for the final decision. f() considers the global distribution of the samples, i.e. learns from all {xi, yi}. Although all the information in training dataset is embodied in the weights of the encoder2, we construct the learning method in such a way that decision is dominated by the prototypes with high weights.\nii. From the encoded information, we can find a decision function so that the mapping g(vi; \u03b7) is close to the ground truth yi, in a consistent way with conventional supervised learning.\niii. Given candidates x(c)j to select the prototypes from, there exists weights pi,j (where pi,j \u2265 0 and \u2211D j=1 pi,j = 1), such that the decision g( \u2211D j=1 pi,jv (c) j ; \u03b7) (where v (c) j = f(x (c) j ; \u03b8))\nis close to the ground truth yi. iv. When the linear combination \u2211D j=1 pi,jv (c) j is considered, prototypes with higher weights\npi,j have higher contribution in the decision g( \u2211D j=1 pi,jv (c) j ; \u03b7).\nv. The weights should be sparse \u2013 only a controllable amount of weights pi,j should be nonzero. Ideally, there exists an efficient mechanism for outputting pi,j to control the sparsity without significantly affecting performance. vi. The weights pi,j depend on the relation between input and the candidate samples, pi,j = r(xi,x (c) j ;\u0393), based on their perceptual relation for decision making. We do not introduce\nany heuristic relatedness metric such as distances in the representation space, but we allow the model to learn the relation function that helps the overall performance.\n1S represents the trainable parameters for s(;S) and is sometimes not show for notation convenience. 2Training of f() may also involve initializing with pre-trained models or transfer learning.\nLearning involves optimization of the parameters \u03b8,\u0393, \u03b7 of the corresponding functions. If the proposed principles (such as reasoning from the linear combination of embeddings or assigning relevance to the weights) are not imposed during training but only at inference, a high performance cannot be obtained due to the train-test mismatch, as the intermediate representations can be learned in an arbitrary way without any necessities to satisfy them.3 The subsequent section presents ProtoAttend and training procedure to implement it."}, {"heading": "3.1 NETWORK ARCHITECTURE AND TRAINING", "text": "The principles above are conditioned on efficient learning of an encoding function to encode the relevant information for decision making, a relation function to determine the prototype weights, and a final decision making block to return the output. Conventional supervised learning comprises the encoding and decision blocks. On the other hand, it is challenging to design a learning method with a relation function with a reasonable complexity. To this end, we adapt the idea of attention (Corbetta & Shulman, 2002; Vaswani et al., 2017), where the model focuses on an adaptive small portion of input while making the decision. Different from conventional employment of attention in sequence or visual learning, we propose to use attention at sample level, such that the attention mechanism is used to determine the prototype weights by relating the input and the candidate samples via alignment of their keys and queries. Fig. 2 shows the proposed architecture for training and inference. The three main blocks are described below:\nEncoder: A trainable encoder is employed to transform B input samples (note that B may be 1 at inference) and D samples from the database of prototype candidates (note that D may be as large as the entire training dataset at inference) into keys, queries and values. The encoder is shared and jointly updated for the input samples and prototype candidate database, to learn a common representation space for the values. The encoder architecture can be based on any trainable discriminative feature mapping function, e.g. ResNet (He et al., 2016) for images, with the modification of generating three types of embeddings. For mapping of the last encoder layer to key, query and value embeddings, we simply use a single fully-connected layer with a nonlinearity, separately for each.4 For input samples, V \u2208 <B\u00d7dout and Q \u2208 <B\u00d7datt denote the values and queries, and for candidate database samples K(c) \u2208 <D\u00d7datt and V(c) \u2208 <D\u00d7dout denote the keys and values.\n3For example, commonly-used distance metrics in the representation spaces fail at determining perceptual relevance of between samples when the model is trained in a vanilla way (Sitawarin & Wagner, 2019).\n4There are other viable options for the mapping but we restrict it to a single layer to minimize the additional number of trainable parameters, which becomes negligible in most cases.\nRelational attention: The relational attention yields the weight between the ith sample and jth candidate, pi,j , via alignment of the corresponding key and query in dot-product attention form5:\npi,j = n ( K (c) j Qb T / \u221a datt ) , (1)\nwhere n() is a normalization function to satisfy pb,j \u2265 0 and \u2211D\nj=1 pb,j = 1 for which we consider softmax and sparsemax (Martins & Astudillo, 2016)6. The choice of the normalization function is an efficient mechanism to control the sparsity of the prototype weights, as demonstrated in experiments. Note that the relational attention mechanism does not introduce any extra trainable parameters.\nDecision making: The final decision block simply consists of a linear mapping from a convex combination of values that results in the output yi. Consider the convex combination of value embeddings, parameterized by \u03b1:\ny\u0302i(\u03b1) = g ( (1\u2212 \u03b1)vi + \u03b1 \u2211D j=1 pi,jv (c) j ) . (2)\nFor \u03b1 = 0, L (yi, y\u0302i(0)) is the conventional supervised learning loss (ignoring the relational attention mechanism) that can only impose principles (i) and (ii), but not the principles (iii)-(vi). A high accuracy for y\u0302i(0) merely indicates that the value embedding space represents each input sample accurately. For \u03b1 = 1, L (yi, y\u0302i(1)) encourages the principles (i), (iii)-(iv), but not the principles (ii) and (vi).7 A high accuracy for y\u0302i(1) indicates that the linear combination of value embeddings accurately maps to the decision. For (vi), we propose that there should be a similar output mapping for the input and prototypes, for which we encourage high accuracy for both y\u0302i(0) and y\u0302i(1) with a loss term that is a mixture of L (yi, y\u0302i(0)) and L (yi, y\u0302i(1)) or guidance with an intermediate term, as y\u0302i(0.5), is required. Lastly, when \u03b1 \u2264 0.5, we obtain the condition that the input sample itself has the largest contribution in the linear combination. Intuitively, the sample itself should be more relevant for the output compared to other samples, so the principles (iii) and (iv) can be encouraged. We propose and compare different training objective functions in Table 1. We observe that the last four are all viable options as the training objective, with similar performance. We choose the last one for the rest of the experiments, as in some cases, slightly better prototypes are observed qualitatively (see Sect. 5.2 for further discussion).\nTo control the sparsity of the weights (beyond the choice of the attention operation), we also propose a sparsity regularization term with a coefficient \u03bbsparse in the form of entropy, Lsparse(p) = \u22121/B \u2211B i=1 \u2211D j=1 pi,j log(pi,j + ), where is a small number for numerical stability. Lsparse(p) is minimized when p has only 1 non-zero value."}, {"heading": "3.2 CONFIDENCE SCORING USING PROTOTYPES", "text": "ProtoAttend provides a linear decomposition (via value embeddings) of the decision into prototypes that have known labels. Ideally, labels of the prototypes should all be the same as the labels of the\n5We use Ai to denote the ith row of A. 6Sparsemax encourages sparsity by mapping the Euclidean projection onto the probabilistic simplex. 7For example, simply assigning non-zero weights to another predetermined class, prototypical learning\nmethod can obtain perfect accuracy, but the assignment of predetermined class would be arbitrary.\ninput. When prototypes with high weights belong to the same class, the model shall be more confident and a correct classification result is expected, whereas in the cases of disagreement between prototype labels, the model shall be less confident and the likelihood of a wrong prediction is higher. With the motivation of separating correct vs. incorrect decisions via its value, we propose a confidence score based on the agreement between the prototypes:\nCi = D\u2211 j=1 pi,j \u00b7 I(y(c)j = y\u0302i), (3)\nwhere I() is the indicator function. Table 1 shows the significant difference of the average confidence metric between correct vs. incorrect classification cases for the test dataset, as desired. In Fig. 3, the impact of confidence on accuracy is further analyzed with the reliability diagram as in (Papernot & McDaniel, 2018). When test samples are binned according to their confidence, it is observed that the bins with higher confidence yield much higher accuracy. There are small number of samples in the bins with lower confidence, and those tend to be the incorrect classification cases. In Section 4.4, the efficacy of confidence score in separating correct vs. incorrect classification is experimented in confidence-controlled prediction setting, demonstrating how much the prediction accuracy can be improved by refraining from small number of samples with low confidence at test time.\nTo further encourage confidence during training, we also consider a regularization term Lconf (p) = \u22121/B \u2211B i=1 \u2211D j=1 pi,j \u00b7 I(y (c) j = yi) with a coefficient \u03bbconf . Lconf is minimized when all prototypes with pi,j > 0 are from the same ground truth class with output yi.8"}, {"heading": "4 EXPERIMENTS", "text": ""}, {"heading": "4.1 SETUP", "text": "We demonstrate the results of ProtoAttend for image, text and tabular data classification problems with different encoder architectures (see Supplementary Material for details). Outputs of the encoders are mapped to queries, keys and values using a fully-connected layer followed by ReLU. For values, layer normalization (Lei Ba et al., 2016) is employed for more stable training. A fully-connected layer is used in the decision making block, yielding logits for determining the estimated class. Softmax cross entropy loss is used as L(). Adam optimization algorithm is employed (Kingma & Ba, 2014) with exponential learning rate decay (with parameters optimized on a validation set). For image encoding, unless specified, we use the standard ResNet model (He et al., 2016). For text encoding, we use the very deep convolutional neural network (VDCNN) (Conneau et al., 2016) model, inputting sequence of raw characters. For tabular data encoding, we use an LSTM model (Hochreiter &\n8Note that the gradients of this regularization term with respect to pi,j is either 0 or 1 and it is often insufficient to train the model itself from scratch. But it is observed to provide further improvements in some cases.\nSchmidhuber, 1997), which inputs the feature embeddings at every timestep. See Supplementary Material for implementation details, additional results and discussions."}, {"heading": "4.2 SPARSE EXPLANATIONS OF DECISIONS", "text": "We foremost demonstrate that our inherently-interpretable model design does not cause significant degradation in performance. Table 2 shows the accuracy and the median number of prototypes required to add up to a particular portion of the decision9 for different prototypical learning cases. In all cases, very small accuracy gap is observed with the baseline encoder that is trained in conventional supervised learning way. The attention normalization function and sparsity regularization are efficient mechanisms to control the sparsity \u2013 the number of prototypes required is much lower with sparsemax attention compared to softmax attention and can be further reduced with sparsity regularization (see Supplementary Material for details). With a small decrease in performance, the number of prototypes can be reduced to just a handful.10 There is difference between datasets, as intuitively expected from the discrepancy in the degree of similarity between the intra-class samples.\nFigs. 4, 5 and 6 exemplify prototypes for image, text and tabular data. In general, perceptually-similar samples are chosen as the prototypes with the largest weights. We also compare the relevant samples found by ProtoAttend with the methods of representer point selection (Yeh et al., 2018) and influence functions (Koh & Liang, 2017) (see Supplementary Material for details) on Animals with Attributes dataset. As shown in Fig. 7, our method finds qualitatively more relevant samples. This case also exemplifies the potential of our method for integration into pre-trained models by addition of simple layers for key, query and value generation."}, {"heading": "4.3 ROBUSTNESS TO LABEL NOISE", "text": "As prototypical learning with sparsemax attention aims to extract decision-making information from a small subset of training samples, it can be used to improve performance when the training dataset\n9E.g. if the prototype weights are [0.2, 0.15, 0.15, 0.25, 0.1, 0.05, 0.28, 0.02], then 2 prototypes are required for 50% of the decision, 6 for 90% and 7 for 95%.\n10We observe that excessively high sparsity (e.g. to yield 1-2 prototypes in most cases) may sometimes decrease the quality of prototypes due to overfitting to discriminative features that are less perceptually meaningful.\ncontains noisy labels (see Table 3). The optimal value11 of \u03bbsparse increases with higher noisy label ratios, underlining the increasing importance of sparse learning.\n4.4 CONFIDENCE-CONTROLLED PREDICTION\nBy varying the threshold for the confidence metric, a trade-off can be obtained for what ratio of the test samples that the model makes a prediction for vs. the overall accuracy it obtains on the samples\n11For a fair comparison, we re-optimize the learning rate parameters on a separate validation set.\nabove that threshold.12 Figs. 8(a) and 8(b) demonstrate this trade-off and compare it to alternative methods. The sharper slope of the plots show that our method is superior to dkNN (Papernot & McDaniel, 2018) and trust score (Jiang et al., 2018), the methods based on quantifying the mismatch with nearest-neighbor samples, in terms of finding related samples. Although the baseline accuracy is higher with 4 ensemble networks obtained via deep ensemble (Lakshminarayanan et al., 2017), our method utilizes a single network and the additional accuracy gains by refraining from uncertain predictions is similar to our approach as shown by the similar slopes of the curves.\nOverall, the baseline accuracy can be significantly improved by making less predictions. Compared to the state of the art models, our canonical method with simple and small models shows similar accuracy by making slightly fewer predictions \u2013 e.g. for MNIST, (Wan et al., 2013) achieves 0.21% error rate, that is obtained by our method refraining from only 0.45% of predictions using ResNet-32 and for DBpedia, (Sachan & Petuum, 2018) achieves 0.91% error, that is obtained by our method refraining from 3% of predictions using 9-layer VDCNN. In general, the smaller the number of prototypes, the smaller the trade-off space. Thus, softmax attention (which normally results in more prototypes) is better suited for confidence-controlled prediction compared to sparsemax (see Supplementary Material for more comparisons)."}, {"heading": "4.5 OUT-OF-DISTRIBUTION SAMPLES", "text": "Well-calibrated confidence scores at inference can be used to detect deviations from the training dataset. As the test distribution deviates from the training distribution, prototype weights tend to mismatch more and yield lower confidence scores. Fig. 9 (a) shows the ratio of samples above a certain confidence level as the test dataset deviates. Rotations deviate the distribution of test images from the training images, and cause significant degradation in confidence scores, as well as the overall accuracy. On the other hand, using test image from a different dataset, degrade them even further. Next, Fig. 9 (b) shows quantification of out-of-distribution detection with prototypical learning, using the method from (Hendrycks & Gimpel, 2016). ProtoAttend yields an AUC of 0.838, being on par with the-state of the art approaches (Hendrycks et al.).\n12Note that this trade-off is often more meaningful to consider rather than the metrics based on the actual value of confidence score itself, as methods may differ in how they define the confidence metric, and thus yield very different ranges and distributions for it."}, {"heading": "5 COMPUTATIONAL COST", "text": "ProtoAttend requires only a very small increase in the number of learning parameters (merely two extra small matrices for the fully-connected layers to obtain queries and keys). However, it does require a longer training time and has higher memory requirements to process the candidate database. At inference, keys and values for the candidate database can be computed only once and integrated into the model. Thus, the overhead merely becomes the computation of attention outputs (e.g. for CIFAR-10 model, the attention overhead at inference is less than 0.6 MFLOPs, orders of magnitude lower than the computational complexity of a ResNet model). During training on the other hand, both forward and backward propagation steps for the encoder need to be computed for all candidate samples and the total time is higher (e.g. 4.45 times slower to train until convergence for CIFAR-10 compared to the conventional supervised learning). The size of the candidate database is limited by the memory of the processor, so in practice we sample different candidate databases randomly from the training dataset at each iteration. For faster training, data and model parallelism approaches are straightforward to implement \u2013 e.g., different processors can focus on different samples, or they can focus on different parts of the convolution or inner product operations. Further computationally-efficient approaches may involve less frequent updates for candidate queries and values."}, {"heading": "6 CONCLUSIONS", "text": "We propose an attention-based prototypical learning method, ProtoAttend, and demonstrate its usefulness for a wide range of problems on image, text and tabular data. By adding a relational attention mechanism to an encoder, prototypical learning enables novel capabilities. With sparsemax attention, it can base the learning on a few relevant samples that can be returned at inference for interpretability, and can also improves robustness to label noise. With softmax attention, it enables confidence-controlled prediction that can outperform state of the art results with simple architectures by simply making slightly fewer predictions, as well as enables detecting deviations from the training data. All these capabilities are achieved without sacrificing overall accuracy of the base model."}, {"heading": "7 ACKNOWLEDGEMENTS", "text": "Discussions with Zizhao Zhang, Chih-Kuan Yeh, Nicolas Papernot, Ryan Takasugi, Andrei Kouznetsov, and Andrew Moore are gratefully acknowledged."}, {"heading": "A TRAINING DETAILS", "text": "Different candidate databases are sampled randomly from the training dataset at each iteration. Training database size is chosen to fit the model to the memory of a single GPU. D at inference is chosen sufficiently large to obtain high accuracy. Table 4 shows the database size D for the datasets used in the experiments.\nA.1 IMAGE DATA"}, {"heading": "A.1.1 MNIST DATASET", "text": "We apply random cropping after padding each side by 2 pixels and per image standardization. The base encoder uses a standard 32 layer ResNet architecture. The number of filters is initially 16 and doubled every 5 blocks. In each block, two 3\u00d7 3 convolutional layers are used to transform the input, and the transformed output is added to the input after a 1 \u00d7 1 convolution. 4\u00d7 downsampling is applied by choosing the stride as 2 after 5th and 10th blocks. Each convolution is followed by batch normalization and ReLU nonlinearity. After the last convolution, 7\u00d7 7 average pooling is applied. The output is followed by a fully-connected layer of 256 units and ReLU nonlinearity, followed by layer normalization (Lei Ba et al., 2016). Keys and queries are mapped from the output using a fully-connected layer followed by ReLU nonlinearity, where the attention size is datt=16. Values are mapped from the output using a fully-connected layer of dout=64 units and ReLU nonlinearity, followed by layer normalization. For the baseline encoder, the initial learning rate is chosen as 0.002 and exponential decay is applied with a rate of 0.9 applied every 6k iterations. The model is trained for 84k iterations. For prototypical learning model with softmax attention, the initial learning rate is chosen as 0.002 and exponential decay is applied with a rate of 0.8 applied every 8k iterations. The model is trained for 228k iterations. For prototypical learning model with sparsemax attention, the initial learning rate is chosen as 0.001 and exponential decay is applied with a rate of 0.93 applied every 6k iterations. The model is trained for 228k iterations. All models use a batch size of 128 and gradient clipping above 20."}, {"heading": "A.1.2 FASHION-MNIST DATASET", "text": "We apply random cropping after padding each side by 2 pixels, random horizontal flipping, and per image standardization. The base encoder uses a standard 32 layer ResNet architecture, similar to our MNIST experiments. For the baseline encoder, the initial learning rate is chosen as 0.0015 and exponential decay is applied with a rate of 0.9 applied every 10k iterations. The model is trained for 332k iterations. For prototypical learning with softmax attention, the initial learning rate is chosen as 0.0007 and exponential decay is applied with a rate of 0.92 applied every 8k iterations. The model is trained for 450k iterations. For prototypical learning with sparsemax attention, the initial learning rate is chosen as 0.001 and exponential decay is applied with a rate of 0.9 applied every 8k iterations. The model is trained for 392k iterations. For prototypical learning with sparsemax attention and sparsity regularization (with \u03bbsparse = 0.0003), the initial learning rate is chosen as 0.001 and exponential decay is applied with a rate of 0.94 applied every 8k iterations. \u03bbconf = 0.1 is chosen when confidence regularization is applied. The model is trained for 440k iterations. All models use a batch size of 128 and gradient clipping above 20."}, {"heading": "A.1.3 CIFAR-10 DATASET", "text": "We apply random cropping after padding each side by 3 pixels, random horizontal flipping, random vertical flipping and per image standardization. The base encoder uses a standard 50 layer ResNet architecture. The number of filters is initially 16 and doubled every 8 blocks. In each block, two 3\u00d7 3 convolutional layers are used to transform the input, and the transformed output is added to the input after a 1\u00d7 1 convolution. 4\u00d7 downsampling is applied by choosing the stride as 2 after 8th and 16th blocks. Each convolution is followed by batch normalization and the ReLU nonlinearity. After the last convolution, 8\u00d7 8 average pooling is applied. The output is followed by a fully-connected layer of 256 units and the ReLU nonlinearity, followed by layer normalization (Lei Ba et al., 2016). The output is followed by a fully-connected layer of 512 units and the ReLU nonlinearity, followed by layer normalization (Lei Ba et al., 2016). Keys and queries are mapped from the output using a fully-connected layer followed by the ReLU nonlinearity, where the attention size is datt=16. Values are mapped from the output using a fully-connected layer of dout=128 units and the ReLU nonlinearity, followed by layer normalization. For the baseline encoder, the initial learning rate is chosen as 0.002 and exponential decay is applied with a rate of 0.95 applied every 10k iterations. The model is trained for 940k iterations. For prototypical learning with softmax attention, the initial learning rate is chosen as 0.0035 and exponential decay is applied with a rate of 0.95 applied every 10k iterations. The model is trained for 625k iterations. For prototypical learning with sparsemax attention, the initial learning rate is chosen as 0.0015 and exponential decay is applied with a rate of 0.95 applied every 10k iterations. The model is trained for 905k iterations. For prototypical learning with sparsemax attention and sparsity regularization (with \u03bbsparse = 0.00008), the initial learning rate is chosen as 0.0015 and exponential decay is applied with a rate of 0.95 applied every 12k iterations. \u03bbconf = 0.1 is chosen when confidence regularization is applied. The model is trained for 450k iterations. All models use a batch size of 128 and gradient clipping above 20.\nCIFAR-10 experiments with noisy labels. For CIFAR-10 experiments with noisy labels for the base encoder we only optimize the learning parameters. Noisy labels are sampled uniformly from the set of labels excluding the correct one. The baseline model with noisy label ratio of 0.8 uses an initial learning rate of 0.001, decayed with a rate of 0.92 every 6k iterations, and is trained for 15k iterations. For the dropout approach, dropout with a rate of 0.1 is applied, and the model uses an initial learning rate of 0.002, decayed with a rate of 0.85 every 8k iterations, and is trained for 24k iterations. The baseline model with noisy label ratio of 0.6 uses an initial learning rate of 0.002, decayed with a rate of 0.92 every 6k iterations, and is trained for 12k iterations. For the dropout approach, dropout with a rate of 0.3 is applied, and the model uses an initial learning rate of 0.002, decayed with a rate of 0.92 every 8k iterations, and is trained for 18k iterations. The baseline model with noisy label ratio of 0.4 uses an initial learning rate of 0.002, decayed with a rate of 0.92 every 6k iterations, and is trained for 15k iterations. For the dropout approach, dropout with a rate of 0.5 is applied, and the model uses an initial learning rate of 0.002, decayed with a rate of 0.92 every 6k iterations, and is trained for 18k iterations. For experiments for the prototypical learning model with sparsemax attention, we optimize the learning parameters and \u03bbsparse. For the model with noisy label ratio of 0.8, \u03bbsparse = 0.0015, initial learning rate is chosen as 0.0006 and exponential decay is applied with a rate of 0.95 applied every 8k iterations. The model is trained for 108k iterations. For the model with noisy label ratio of 0.6, \u03bbsparse = 0.0005, initial learning rate is chosen as 0.001 and exponential decay is applied with a rate of 0.9 applied every 8k iterations. The model is trained for 92k iterations. For the model with noisy label ratio of 0.4, \u03bbsparse = 0.0003, initial learning rate is chosen as 0.001 and exponential decay is applied with a rate of 0.9 applied every 6k iterations. The model is trained for 122k iterations."}, {"heading": "A.1.4 FRUITS DATASET", "text": "We apply random cropping after padding each side by 5 pixels, random horizontal flipping, random vertical flipping and per image standardization. In the encoder, first, a downsampling with a convolutional layer is applied with a stride of 2, and using 16 filters, followed by a downsampling with max-pooling with a stride of 2. After obtaining the 25\u00d7 25 inputs, the a standard 32 layer ResNet architecture (similar to MNIST) is used, followed by a fully-connected layer of 128 units and the ReLU nonlinearity, followed by layer normalization (Lei Ba et al., 2016). Keys and queries are mapped from the output using a fully-connected layer followed by the ReLU nonlinearity, where the attention size is datt=16. Values are mapped from the output using a fully-connected layer of\ndout=64 units and the ReLU nonlinearity, followed by layer normalization. W eight decay with a factor of 0.0001 is applied for the convolutional filters. The model uses a batch size of 128 and gradient clipping above 20.\nA.1.5 ISIC MELANOMA DATASET\nThe ISIC Melanoma dataset is formed from the ISIC Archive (ISIC, 2016) that contains over 13k dermoscopic images collected from leading clinical centers internationally and acquired from a variety of devices within each center. The dataset consists of skin images with labels denoting whether they contain melanoma or are benign. We construct the training and validation dataset using 15122 images (13511 benign and 1611 melanoma cases), and the evaluation dataset using 3203 images (2867 benign and 336 melanoma). While training, benign cases are undersampled in each batch to have 0.6 ratio including candidate database sets at training and inference. All images are resized to 128 \u00d7 128 pixels. We apply random cropping after padding each side by 8 pixels, random horizontal flipping, random vertical flipping and per image standardization. In the encoder, first, a downsampling with a convolutional layer is applied with a stride of 2, and using 16 filters, followed by a downsampling with max-pooling with a stride of 2. After obtaining the 32\u00d7 32 inputs, the base encoder uses a standard 50 layer ResNet architecture (similar to CIFAR10), followed by a fully-connected layer of 128 units and the ReLU nonlinearity, followed by layer normalization (Lei Ba et al., 2016). Keys and queries are mapped from the output using a fully-connected layer followed by the ReLU nonlinearity, where the attention size is datt=16. Values are mapped from the output using a fully-connected layer of dout=64 units and the ReLU nonlinearity, followed by layer normalization. For the baseline encoder, the initial learning rate is chosen as 0.002 and exponential decay is applied with a rate of 0.9 applied every 3k iterations. The model is trained for 220k iterations. For prototypical learning with softmax attention, the initial learning rate is chosen as 0.0006 and exponential decay is applied with a rate of 0.9 applied every 3k iterations. The model is trained for 147k iterations. For prototypical learning with sparsemax attention, the initial learning rate is chosen as 0.0006 and exponential decay is applied with a rate of 0.9 applied every 4k iterations. The model is trained for 166k iterations. All models use a batch size of 128 and gradient clipping above 20."}, {"heading": "A.1.6 ANIMALS WITH ATTRIBUTES DATASET", "text": "We train ProtoAttend with sparsemax attention using the features from a pre-trained ResNet-50 as provided in (Yeh et al., 2018). To map the pre-trained features, we simply insert a single fullyconnected layer with 256 units with ReLU nonlinearity and layer normalization, followed by the individual fully-connected layers of keys, queries and values (16, 16 and 64 units respectively with ReLU nonlinearity). Sparsity regularization is applied with \u03bbsparse = 0.000001. We train the model for 70k iterations. The initial learning rate is chosen as 0.0006 and exponential decay is applied with a rate of 0.8 applied every 10k iterations. A classification accuracy above 91% is obtained for the test set."}, {"heading": "A.2 TEXT DATA", "text": ""}, {"heading": "A.2.1 DBPEDIA DATASET", "text": "There are 14 output classes: Company, Educational Institution, Artist, Athlete, Office Holder, Mean Of Transportation, Building, Natural Place, Village, Animal, Plant, Album, Film, Written Work. As the input, 16-dimensional trainable embeddings are mapped from the dictionary of 69 raw characters (Conneau et al., 2016). The maximum length is set to 448 and longer inputs are truncated while the shorter inputs are padded. The input embeddings are first transformed with a 1-D convolutional block consisting 64 filters with kernel width of 3 and stride of 2. Then, 8 convolution blocks as in (Conneau et al., 2016) are applied, with 64, 64, 128, 128, 256, 256, 512 and 512 filters respectively. All use the kernel width of 3, and after each two layers, max pooling is applied with kernel width of 3 and a stride of 2. All convolutions are followed by batch normalization and the ReLU nonlinearity. Convolutional filters use weight normalization with parameter 0.00001. The last convolution block is followed by k-max pooling with k=8 (Conneau et al., 2016). Finally, we apply two fully-connected layers with 1024 hidden units. In contrast to (Conneau et al., 2016), we also use layer normalization (Lei Ba et al., 2016) after fully-connected layers as we observe this leads to more stable training behavior. Keys and queries are mapped from the output using a fully-connected layer followed by the ReLU nonlinearity,\nwhere the attention size is datt=16. Values are mapped from the output using a fully-connected layer of dout=64 units and the ReLU nonlinearity, followed by layer normalization. For the baseline encoder, initial learning rate is chosen as 0.0008 and exponential decay is applied with a rate of 0.9 applied every 8k iterations. The model is trained for 212k iterations. For prototypical learning model with softmax attention, the initial learning rate is chosen as 0.0008 and exponential decay is applied with a rate of 0.9 applied every 8k iterations. The model is trained for 146k iterations. For prototypical learning model with sparsemax attention, the initial learning rate is chosen as 0.0005 and exponential decay is applied with a rate of 0.82 applied every 8k iterations. The model is trained for 270k iterations. All models use a batch size of 128 and gradient clipping above 20. We do not apply any data augmentation."}, {"heading": "A.3 TABULAR DATA", "text": ""}, {"heading": "A.3.1 ADULT CENSUS INCOME", "text": "There are two output classes: whether or not the annual income is above $50k. Categorical categories such as the \u2018marital-status\u2019 are mapped to multi-hot representations. Continuous variables are used after a fixed normalization transformation. For \u2018age\u2019, the transformation first subtracts 50 and then divides by 30. For \u2018fnlwgt\u2019, the transformation first takes the log, and then subtracts 9, and then divides by 3. For \u2018education-num\u2019, the transformation first subtracts 6 and then divides by 6. For \u2018hours-per-week\u2019, the transformation first subtracts 50 and then divides by 50. For \u2018capital-gain\u2019 and \u2018capital-loss\u2019, the normalization takes the log, and then subtracts 5, and then divides by 5. The concatenated features are then mapped to a 64 dimensional vector using a fully-connected layer, followed by the ReLU nonlinearity. The base encoder uses an LSTM architecture, with 4 timesteps. At each timestep, 64-dimensional inputs are applied after a dropout with rate 0.5. The output of the last timestep is used after applying a dropout with rate 0.5. Keys and queries are mapped from this output using a fully-connected layer followed by the ReLU nonlinearity, where the attention size is datt=16. Values are mapped from the output using a fully-connected layer of dout=16 units and the ReLU nonlinearity, followed by layer normalization. For the baseline encoder, the initial learning rate is chosen as 0.002 and exponential decay is applied with a rate of 0.9 applied every 2k iterations. The model is trained for 4.5k iterations. For the models with attention in prototypical learning framework, the initial learning rate is chosen as 0.0005 and exponential decay is applied with a rate of 0.92 applied every 2k iterations. The softmax attention model is trained for 13.5k iterations and the sparsemax attention model is trained for 11.5k iterations. For the model with sparsity regularization, the initial learning rate is 0.003 and exponential decay is applied with a rate of 0.7 applied every 2k iterations, and the model is trained for 7k iterations. All models use a batch size of 128 and gradient clipping above 20. We do not apply any data augmentation."}, {"heading": "B ADDITIONAL PROTOTYPE EXAMPLES", "text": "Fig. 10 exemplify prototypes for CIFAR-10. For most cases, we observe the similarity of discriminative features between inputs and prototypes. For example, the body figures of birds, the shape of tires, the face patterns of dogs, the body figures of frogs, the appearance of the background sky for planes, are among these features apparent in examples.\nFig. 11 shows additional prototype examples for DBPedia dataset. Prototypes have very similar sentence structure, words and concepts, while categorizing the sentences into ontologies.\nFig. 12 shows example prototypes for ISIC Melanoma. In some cases, we observe the commonalities between input and prototypes that distinguish melanoma cases such as the non-circular geometry or irregularly-notched borders (Jerant et al., 2000). Compared to other datasets, ISIC Melonama dataset yields lower interpretable prototype quality on average. We hypothesize this to be due to the perceptual difficulty of the problem as well as the insufficient encoder performance shown by the lower classification accuracy (despite the acceptable AUC).\nFig. 13 shows more comparison examples for prototypical learning framework with sparsemax attention vs. representer point selection (Yeh et al., 2018) on Animals with Attributes dataset. For some cases, including chimpanzee, zebra, dalmatian and tiger, ProtoAttend yields perceptually very similar samples. The similarity of the chimpanzee body form and the background, zebra patterns, dalmatian pattern on the grass, and tiger pattern and head pose, are prominent. Representer point\nselection fails to capture such similarity features as effectively. On the other hand, for bat, otter and wolf, the results are somewhat less satisfying. The wing part of the bat, multiple count of the otters with the background, and the color and furry head of the wolf seem to be captured, but with less apparent similarity than some other possible samples from the dataset. Representer point selection method also cannot be claimed to be successful in these cases. Lastly, for leopard, ProtoAttend only yields one non-zero prototype (which is indeed statistically rare given the model and sparsity choices). The pattern of the leopard image seems relevant, but it is also not fully satisfying to observe a single prototype that is not perceptually more similar. All of the test examples in Fig. 13 are classified correctly with our framework and all of the shown prototypes are also from the correct classes."}, {"heading": "C COMPARISON OF CONFIDENCE-CONTROLLED PREDICTION FOR SOFTMAX VS. SPARSEMAX", "text": "Figs. 14 and 15 show the accuracy vs. ratio of samples for softmax vs. sparsemax attention without confidence regularization. The baseline accuracy (at 100% prediction ratio) is higher for softmax attention for some datasets, whereas higher for sparsemax for some others. On the other hand, higher number of prototypes yielded by softmax attention results in a wider range for confidence-controlled prediction trade-off.\nAs an impactful case study, we consider melanoma detection problem with ISIC dataset (ISIC, 2016) in Supplementary Material. In medical diagnosis, it is strongly desired to maintain a sufficiently-high prediction performance, potentially by verifying the decisions of an AI systems by medical experts in the cases where the AI models are not confident. By refraining from some predictions, as shown in Fig. 16, we demonstrate unprecedentedly high AUC values without using transfer learning or highly-customized models (Haenssle et al., 2018)."}, {"heading": "D CONTROLLING SPARSITY VIA REGULARIZATION", "text": "Fig. 17 shows the impact of sparsity regularization coefficient on training. By varying the value of \u03bbsparse, the number of prototypes can be efficiently controlled. For high values of sparsity regularization coefficient, the model gets stuck at a point where it is forced to make decision from a low number of prototypes before the encoder model is properly learned, hence typically yields considerably lower performance. We also observe sparsity mechanism via sparsemax attention to yield better performance than softmax attention with high sparsity regularization."}, {"heading": "E PROTOTYPE QUALITY", "text": "In general, the following scenarios may yield low prototype quality:\n1. Lack of related samples in the candidate database. 2. Perceptual difference between humans and encoders in determining discriminative features. 3. High intra-class variability that makes training difficult. 4. Imperfect encoder that cannot yield fully accurate representations of the input. 5. Insufficiency of relational attention to determine weights from queries and keys. 6. Inefficient decoupling between encoder & attention blocks and the final decision block.\nThere can be problem-dependent fundamental limitations on (1)-(3), whereas (4)-(6) are raised by choices of models and losses and can be further improved. We leave the quantification of prototype quality using information-theoretic metrics or discriminative neural networks to future work."}, {"heading": "F UNDERSTANDING MISCLASSIFICATION CASES", "text": "One of the benefits of prototypical learning is insights into wrong decision cases. Fig. 18 exemplifies prototypes with wrong labels, that give insights about why the model is confused about a particular input (e.g. due to similarity of the visual patterns). Such insights can be actionable to improve the model performance, such as adding more training samples for the confusing classes or modifying the loss functions."}], "title": "PROTOATTEND: ATTENTION-BASED PROTOTYPICAL LEARNING", "year": 2019}