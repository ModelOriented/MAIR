{
  "abstractText": "Machine-learning models have been recently used for detecting malicious Android applications, reporting impressive performances on benchmark datasets, even when trained only on features statically extracted from the application, such as system calls and permissions. However, recent findings have highlighted the fragility of such in-vitro evaluations with benchmark datasets, showing that very few changes to the content of Android malware may suffice to evade detection. How can we thus trust that a malware detector performing well on benchmark data will continue to do so when deployed in an operating environment? To mitigate this issue, the most popular Android malware detectors use linear, explainable machine-learning models to easily identify the most influential features contributing to each decision. In this work, we generalize this approach to any black-box machinelearning model, by leveraging a gradient-based approach to identify the most influential local features. This enables using nonlinear models to potentially increase accuracy without sacrificing interpretability of decisions. Our approach also highlights the global characteristics learned by the model to discriminate between benign and malware applications. Finally, as shown by our empirical analysis on a popular Android malware detection task, it also helps identifying potential vulnerabilities of linear and nonlinear models against adversarial manipulations.",
  "authors": [
    {
      "affiliations": [],
      "name": "Marco Melis"
    },
    {
      "affiliations": [],
      "name": "Davide Maiorca"
    },
    {
      "affiliations": [],
      "name": "Battista Biggio"
    },
    {
      "affiliations": [],
      "name": "Giorgio Giacinto"
    },
    {
      "affiliations": [],
      "name": "Fabio Roli"
    }
  ],
  "id": "SP:70c7f491835b8c2b020a97ade2c6f72aabf4254b",
  "references": [
    {
      "authors": [
        "D. Arp",
        "M. Spreitzenbarth",
        "M. H\u00fcbner",
        "H. Gascon",
        "K. Rieck. Drebin"
      ],
      "title": "Efficient and explainable detection of android malware in your pocket",
      "venue": "In Proc. 21st NDSS. The Internet Society,",
      "year": 2014
    },
    {
      "authors": [
        "M. Backes",
        "M. Nauman"
      ],
      "title": "LUNA: quantifying and leveraging uncertainty in android malware analysis through Bayesian machine learning",
      "venue": "In EuroS&P,",
      "year": 2017
    },
    {
      "authors": [
        "D. Baehrens",
        "T. Schroeter",
        "S. Harmeling",
        "M. Kawanabe",
        "K. Hansen",
        "K.-R. M\u00fcller"
      ],
      "title": "How to explain individual classification decisions",
      "venue": "J. Mach. Learn. Res.,",
      "year": 2010
    },
    {
      "authors": [
        "B. Biggio",
        "I. Corona",
        "D. Maiorca",
        "B. Nelson",
        "N. \u0160rndi\u0107",
        "P. Laskov",
        "G. Giacinto",
        "F. Roli"
      ],
      "title": "Evasion attacks against machine learning at test time",
      "venue": "In ECML,",
      "year": 2013
    },
    {
      "authors": [
        "B. Biggio",
        "F. Roli"
      ],
      "title": "Wild patterns: Ten years after the rise of adversarial machine learning",
      "year": 2018
    },
    {
      "authors": [
        "A. Calleja",
        "A. Martin",
        "H.D. Menendez",
        "J. Tapiador",
        "D. Clark"
      ],
      "title": "Picking on the family: Disrupting android malware triage by forcing misclassification",
      "venue": "Expert Systems with Applications,",
      "year": 2018
    },
    {
      "authors": [
        "S. Chen",
        "M. Xue",
        "Z. Tang",
        "L. Xu",
        "H. Zhu"
      ],
      "title": "Stormdroid: A streaminglized machine learning-based system for detecting Android malware",
      "venue": "In ASIA CCS,",
      "year": 2016
    },
    {
      "authors": [
        "F. Doshi-Velez",
        "B. Kim"
      ],
      "title": "Towards A Rigorous Science of Interpretable Machine Learning",
      "venue": "ArXiv,",
      "year": 2017
    },
    {
      "authors": [
        "I.J. Goodfellow",
        "J. Shlens",
        "C. Szegedy"
      ],
      "title": "Explaining and harnessing adversarial examples",
      "venue": "In ICLR,",
      "year": 2015
    },
    {
      "authors": [
        "B. Goodman",
        "S. Flaxman"
      ],
      "title": "European Union regulations on algorithmic decision-making and a \u201cright to explanation",
      "year": 2016
    },
    {
      "authors": [
        "P.W. Koh",
        "P. Liang"
      ],
      "title": "Understanding black-box predictions via influence functions",
      "venue": "In ICML,",
      "year": 2017
    },
    {
      "authors": [
        "Z.C. Lipton"
      ],
      "title": "The mythos of model interpretability",
      "venue": "In ICML Workshop on Human Interpretability in Machine Learning,",
      "year": 2016
    },
    {
      "authors": [
        "M.T. Ribeiro",
        "S. Singh",
        "C. Guestrin"
      ],
      "title": "Why should i trust you?: Explaining the predictions of any classifier",
      "venue": "In KDD,",
      "year": 2016
    },
    {
      "authors": [
        "P. Russu",
        "A. Demontis",
        "B. Biggio",
        "G. Fumera",
        "F. Roli"
      ],
      "title": "Secure kernel machines against evasion attacks",
      "venue": "In AISec,",
      "year": 2016
    },
    {
      "authors": [
        "R. Sommer",
        "V. Paxson"
      ],
      "title": "Outside the closed world: On using machine learning for network intrusion detection",
      "venue": "In IEEE Symp. Security and Privacy, pp",
      "year": 2010
    },
    {
      "authors": [
        "C. Szegedy",
        "W. Zaremba",
        "I. Sutskever",
        "J. Bruna",
        "D. Erhan",
        "I. Goodfellow",
        "R. Fergus"
      ],
      "title": "Intriguing properties of neural networks",
      "venue": "In ICLR,",
      "year": 2014
    },
    {
      "authors": [
        "C. Szegedy",
        "W. Zaremba",
        "I. Sutskever",
        "J. Bruna",
        "D. Erhan",
        "I. Goodfellow",
        "R. Fergus"
      ],
      "title": "Intriguing properties of neural networks",
      "venue": "In ICLR,",
      "year": 2014
    },
    {
      "authors": [
        "L. Breiman"
      ],
      "title": "Some infinity theory for predictor ensembles",
      "venue": "Technical Report 579, Statistics Dept. UCB,",
      "year": 2000
    }
  ],
  "sections": [
    {
      "text": "Explaining Black-box Android Malware Detection Marco Melis\u2217, Davide Maiorca\u2217, Battista Biggio\u2217\u2020, Giorgio Giacinto\u2217\u2020 and Fabio Roli\u2217\u2020\n\u2217DIEE, University of Cagliari, Piazza d\u2019Armi, 09123, Cagliari {marco.melis,davide.maiorca,battista.biggio,giacinto,roli}@diee.unica.it\n\u2020 Pluribus One, Italy\nAbstract\u2014Machine-learning models have been recently used for detecting malicious Android applications, reporting impressive performances on benchmark datasets, even when trained only on features statically extracted from the application, such as system calls and permissions. However, recent findings have highlighted the fragility of such in-vitro evaluations with benchmark datasets, showing that very few changes to the content of Android malware may suffice to evade detection. How can we thus trust that a malware detector performing well on benchmark data will continue to do so when deployed in an operating environment? To mitigate this issue, the most popular Android malware detectors use linear, explainable machine-learning models to easily identify the most influential features contributing to each decision. In this work, we generalize this approach to any black-box machinelearning model, by leveraging a gradient-based approach to identify the most influential local features. This enables using nonlinear models to potentially increase accuracy without sacrificing interpretability of decisions. Our approach also highlights the global characteristics learned by the model to discriminate between benign and malware applications. Finally, as shown by our empirical analysis on a popular Android malware detection task, it also helps identifying potential vulnerabilities of linear and nonlinear models against adversarial manipulations.\nI. INTRODUCTION With more than 400 millions of malicious applications discovered in the wild, Android malware constitutes one of the major threats in mobile security. Among the various detection strategies proposed by companies and academic researchers, those based on machine learning have shown the most promising results, due to their flexibility against malware variants and obfuscation attempts [1], [7]. Despite the impressive performances reported by such approaches on benchmark datasets, the problem of Android malware detection in the wild is still far from being solved. The validity of such optimistic, in-vitro evaluations has been indeed questioned from recent adversarial analyses showing that only few changes to the content of a malicious Android application may suffice to evade detection by a learning-based detector [6], [8]. Besides this fragility to well-crafted evasion attacks (a.k.a. adversarial examples) [4], [5], [10], [18], Sommer and Paxson [16] have more generally questioned the suitability of black-box machine-learning approaches to computer security. In particular, how can we thus trust the predictions of a machine-learning model in vivo, i.e., when it is deployed in an operating environment, to take subsequent reliable actions? How can we understand whether we are selecting a proper model before deployment? How about its security properties against adversarial attacks?\nTo partially address these issues, Android malware detectors often restrict themselves to the use of linear, explainable\nmachine-learning models that allow one to easily identify the most influential features contributing to each decision (Sect. II) [1], [2]. More generally, intepretability of machinelearning models has recently become a relevant research direction to more thoroughly address and mitigate the aforementioned issues, especially in the case of nonlinear blackbox machine-learning algorithms [3], [9], [12]\u2013[14]. Some approaches aim to explain local predictions (i.e., on each specific sample) by identifying the most influential features [3], [14] or prototypes from training data [12]. Others have proposed techniques and methodologies towards providing global explanations about the salient characteristics learned by a given machine-learning algorithm [9], [13].\nIn this work, we generalize current explainable Android malware detection approaches to any black-box machinelearning model, by leveraging a gradient-based approach to identify the most influential local features (Sect. III). For non-differentiable learning algorithms, like decision trees, we extract gradient information by learning a differentiable approximation. Notably, this idea has originally been exploited to construct gradient-based evasion attacks against non-differentiable learners, and evaluate their transferability, i.e., the probability that an attack crafted against a learning algorithm succeeds against a different one [4], [10], [15]. Accordingly, our approach provides interpretable decisions even for Android malware detectors exploiting nonlinear learning algorithms to potentially increase detection accuracy. Moreover, by averaging the local relevant features across different classes of samples, our approach allows also highlighting the global characteristics learned by a given model to identify benign applications and different classes of Android malware.\nWe perform our experimental analysis with a popular Android malware detector named Drebin [1] (Sect. IV). It extracts information the Android application through static analysis, and provides interpretable decisions by leveraging a linear classification algorithm. To test the validity of our approach, we show how to retain the interpretability of Drebin on nonlinear algorithms, including Support Vector Machines (SVMs) and Random Forests (RFs). Interestingly, we also show that the interpretations provided by our approach can help identifying potential vulnerabilities of both linear and nonlinear Android malware detectors against adversarial manipulations.\nWe conclude the paper by discussing contributions and limitations of this work, and future research directions towards developing more robust malware detectors (Sect. V).\nar X\niv :1\n80 3.\n03 54\n4v 2\n[ cs\n.L G\n] 2\n9 O\nct 2\n01 8"
    },
    {
      "heading": "II. ANDROID MALWARE DETECTION",
      "text": "In this section, we provide some background on how Android applications are structured, and then discuss Drebin [1], the malware detector used in our analysis."
    },
    {
      "heading": "A. Android Background",
      "text": "Android applications are apk files, i.e., zipped archives that must contain two files: the Android manifest and the classes.dex. Additional xml and resource files are respectively used to define the application layout and to provide multimedia contents. As Drebin only analyzes the Android manifest and classes.dex files, we briefly describe them below.\nAndroid Manifest. The manifest file holds information about how the application is organized in terms of its components, i.e., parts of code that perform specific actions; e.g., one component might be associated to a screen visualized by the user (activity) or to the execution of audio in the background (services). It is also possible to perform actions on the occurrence of a specific event (receivers). The actions of each component are further specified through filtered intents; e.g., when a component sends data to other applications, or is invoked by a browser. Special types of intent filters (e.g., LAUNCHER) can specify that a certain component is executed as soon as the application is opened. The manifest also contains the list of hardware components and permissions requested by the application to work (e.g., Internet access).\nDalvik Bytecode (dexcode). The classes.dex file embeds the compiled source code of an application, including all the userimplemented methods and classes. Classes.dex may contain specific API calls that can access sensitive resources such as personal contacts (suspicious calls). Additionally, it contains all system-related, restricted API calls whose functionality require permissions (e.g., using the Internet). Finally, this file can contain references to network addresses that might be contacted by the application."
    },
    {
      "heading": "B. Drebin",
      "text": "Drebin performs a lightweight static analysis of Android applications. The extracted features are used to embed benign and malware apps into a high-dimensional vector space, train a machine-learning model, and then perform classification of never-before-seen apps. An overview of the system architecture is given in Fig. 1, and discussed more in detail below.\nFeature extraction. First, Drebin statically analyzes a set of available Android applications to construct a suitable feature space. All features extracted by Drebin are presented as strings and organized in 8 different feature sets, as listed in Table I. Android applications are then mapped onto the feature space as follows. Let us assume that an app is represented as an object z \u2208 Z , being Z the abstract space of all apk files. We then denote with \u03a6 : Z 7\u2192 X a function that maps an apk file z to a d-dimensional feature vector x = (x1, . . . , xd)> \u2208 X = {0, 1}d, where each feature is set to 1 (0) if the corresponding string is present (absent) in the apk file z. An application encoded in feature space may thus look like the following:\nx = \u03a6(z) 7\u2192  \u00b7 \u00b7 \u00b7 0 1 \u00b7 \u00b7 \u00b7 1 0 \u00b7 \u00b7 \u00b7  \u00b7 \u00b7 \u00b7 } S2 permission::SEND_SMS permission::READ_SMS \u00b7 \u00b7 \u00b7 } S5 api_call::getDeviceId api_call::getSubscriberId \u00b7 \u00b7 \u00b7\nLearning and Classification. Drebin uses a linear SVM to perform detection. It can be expressed in terms of a linear function f : X 7\u2192 R, i.e., f(x) = w>x + b, where w \u2208 Rd denotes the vector of feature weights, and b \u2208 R is the so-called bias. These parameters, optimized during training, identify a hyperplane that separates the two classes in feature space. During classification, unseen apps are then classified as malware if f(x) \u2265 0, and as benign otherwise. Explanation. Drebin explains its decisions by reporting, for any given application, the most influential features, i.e., the features that are present in the given application and are assigned the highest absolute weights by the classifier. For instance, in Fig. 1, it is easy to see, from its most influential features, that a malware sample is correctly identified by Drebin as it connects to a suspicious URL and uses SMS as a side channel for communication. As we aim to extend this approach to nonlinear models, in this work we also consider an SVM with the Radial Basis Function (RBF) kernel and a random forest to learn nonlinear functions f(x).\nIII. INTERPRETING DECISIONS OF LEARNING-BASED BLACK-BOX ANDROID MALWARE DETECTORS\nWe discuss here our idea to generalize the explainable decisions of Drebin and other locally-explainable Android malware detectors [1], [2] to any black-box (i.e., nonlinear) machine-learning algorithm. In addition, we also propose a method to explain the global characteristics influencing the decisions of the learning-based malware detector at hand. Local explanations. Previous work has highlighted that gradients and, more generally, linear approximations computed around the input point x convey useful information for explaining the local predictions provided by a learning algorithm [3], [14]. The underlying idea is to identify as most influential those features associated to the highest (absolute) values of the local gradient \u2207f(x), being f the confidence associated to the predicted class. However, in the case of sparse data, as for Android malware, these approaches tend to identify a high number of influential features which are not present in the given application, thus making the corresponding predictions difficult to interpret. For this reason, in this\nwork we consider a slightly different approach, inspired from the notion of directional derivative. In particular, we project the gradient\u2207f(x) onto x to obtain a feature-relevance vector \u03bd = \u2207f(x) \u00b7 x \u2208 Rd, where \u00b7 denotes the element-wise product. We then normalize \u03bd to have a unary `1 norm, i.e., r = \u03bd/\u2016\u03bd\u20161, to ensure that only non-null features in x are identified as relevant for the decision. Finally, the absolute values of r can be ranked in descending order to identify the most influential local features.\nGlobal explanations. In contrast to other locally-explainable malware detectors [1], [2], we also provide a global analysis of the interpretability of the considered machine-learning models, aimed to identify the most influential features, on average, which characterize benign and malware samples. Our idea is simply to average the relevance vectors r over different samples, e.g., separately for benign and malware data. Then, as in the local case, the absolute values of the average relevance vector r\u0304 can be ranked in descending order to identify the most influential global features.\nNon-differentiable models. Our approach works under the assumption that f(x) is differentiable and that its gradient \u2207f(x) is sufficiently smooth to provide meaningful information at each point. When f(x) is not differentiable (e.g., for decision trees and random forests), or its gradient vanishes (e.g., if f(x) becomes constant in large regions of the input space), we compute approximate feature-relevance vectors by means of surrogate models. The idea is to train a differentiable approximation f\u0302(x) of the target function f(x), similar to what has been done in [3] for interpretability of non-differentiable models, and in [4], [15] to craft gradient-based evasion attacks against non-differentiable learning algorithms. For instance, to reliably estimate a non-differentiable algorithm f(x) (e.g., a random forest), one can train a nonlinear SVM on a training set relabeled with the predictions provided by f(x) [15]."
    },
    {
      "heading": "IV. EXPERIMENTAL ANALYSIS",
      "text": "In this section, we use our approach to provide local and global explanations for linear and nonlinear (including non-differentiable) classifiers trained on the features used by Drebin. As we will see, this will also reveal some insights on their security against adversarial manipulations [6], [8].\nDatasets. We use here the Drebin data [1], consisting of 121, 329 benign applications and 5, 615 malicious samples, labeled with VirusTotal. A sample is labeled as malicious if it is detected by at least five anti-virus scanners, whereas it is labeled as benign if no scanner flagged it as malware.\nTraining-test splits. We average our results on 5 runs. In each run, we randomly select 60,000 apps from the Drebin data to train the learning algorithms, and use the rest for testing.\nClassifiers. We compare the standard Drebin implementation based on a linear SVM (SVM) against an SVM with the RBF kernel (SVM-RBF) and a (non-differentiable) Random Forest (RF). As discussed in Sect. III, a surrogate model is needed to interpret the RF; to this end, we train an SVM with the RBF kernel on the training set relabeled by the RF (yielding an approximation with accuracy higher than 99% on average on the relabeled testing sets). The Receiver Operating Characteristic (ROC) curve for each classifier, averaged over the 5 repetitions, is reported in Fig. 2.\nParameter setting. We optimize the parameters of each classifier through a 3-fold cross-validation procedure. In particular, we optimize C \u2208 {10\u22122, 10\u22121, . . . , 102} for both linear and non-linear SVMs, the kernel parameter \u03b3 \u2208 {10\u22124, 10\u22123, . . . , 102} for the SVM-RBF, and the number of estimators n \u2208 {5, 10, . . . , 30} for the RF."
    },
    {
      "heading": "A. Local Explanations",
      "text": "Table II reports the top-10 influential features, sorted by their (absolute) relevance values, for three distinct samples classified by the linear SVM and the RF classifier, along with their probability of being present in each class. Notably, relevant features can also be rare. This means that a feature is deemed relevant even if it characterizes well only a small subset of samples in a given class (e.g., a malware family).\nCase 1. The first example is a benign application misclassified by the SVM with a score of \u22120.17, and correctly classified by the RF (probability 0.77% and surrogate score of +0.10). By observing the features through their relevance scores, it is\nevident that the RF is able to correctly classify this sample as benign as several features are assigned a negative relevance score, while almost all of them are considered as malicious (positive score) by the SVM. In both cases the use of SMS messages for communication is retained suspicious; however, for the RF this is not a sufficient evidence of maliciousness.\nCase 2. The second example is a malware sample of the SmsWatcher family, which is correctly classified by the SVM (score +0.99), but not by the RF model (probability 0.3% and surrogate score of \u22121.43), for a reason similar to the previous case: permissions (S2) and API calls (S7) related to SMS usage are not a sufficient evidence of maliciousness for the RF. Indeed, this classifier does not even identify as suspicious the application components (S3) related to SMS usage, which instead constitute a signature for this malware family, as correctly learned by the linear SVM model.\nCase 3. The last case is a malware sample of the Plankton family, correctly classified by both models (SVM score +2.75; RF probability 0.9% and surrogate score +1.32), as they correctly identified the behavioral patterns of this family associated to HTTP communication and actions."
    },
    {
      "heading": "B. Global Explanations",
      "text": "We performed a global analysis of the models learned by each algorithm by averaging the local relevance vectors r over different classes of samples: benign, malware, and the top15 malware families with the largest number of samples in the Drebin data (Table III). This gives us a global (mean) relevance vector r\u0304 for each class. Then, for each class of samples, we report a compact and a fine-grained analysis of the global feature-relevance values r\u0304. In the compact analysis, we further average the global relevance r\u0304 over each feature set S1, . . . , S8 (Table I). In the fine-grained analysis, we simply report the global relevance score r\u0304 for the top 44 features (selected by aggregating the top 5 features with the highest average relevance score for each class of samples).\nThe results are shown in Fig. 3. The compact analysis highlights the importance of permissions (S2) and suspicious API calls (S7 group) in identifying malware. This is reasonable, as the majority of malware samples require permissions to perform specific actions, like stealing contacts and opening SMS and other side communication channels. The fine-grained analysis provides a more detailed characterization of the aforementioned behavior, highlighting how each classifier learns a specific behavioral signature for each class of samples. In particular, malware families are characterized by their communication channels (e.g., SMS and HTTP), by the amount of stolen information and accessed resources, and by specific application components or URLs (S3 and S8).\nFinally, note that all classifiers tend to assign high relevance to a very small set of features in each decision, both at a local and at a global scale. Given that manipulating the content of Android malware can be relatively easy, especially due to the possibility of injecting dead code, this behavior highlights the potential vulnerability of such classifiers. In fact, if the decisions of a classifier rely on few features, it is intuitive that detection can be easily evaded by manipulating only few of them, as also confirmed in previous work [6], [8]. Conversely, if a model distributes relevance more evenly among features, evasion may be more difficult (i.e., require manipulating a higher number of features, which may not be always feasible). More robust learning algorithms for these tasks have been proposed based exactly on this rationale, which has also a theoretically-sound interpretation [8].\nAnother interesting point regards the transferability of evasion attacks across different models, i.e., the fact that an attack crafted against a specific classifier may still be successful with high probability against a different one. From our analysis, it is clear that in this case this property depends more on the available training data rather than on the specific learning algorithm: the three considered classifiers learn very similar patterns of feature relevances, as clearly highlighted in Fig. 3, which simply means that they can be evaded with very similar modifications to the input sample."
    },
    {
      "heading": "V. CONTRIBUTIONS, LIMITATIONS AND FUTURE WORK",
      "text": "In this paper, we provided a general approach to achieve explainable malware detection on Android, applicable to any\nblack-box machine-learning model. Our explainable approach can help analysts to understand possible vulnerabilities of learning algorithms to well-crafted evasion attacks along with their transferability properties, besides providing a local and global understanding of how a machine-learning model makes its decisions. We plan to analyze also different strategies to provide global explanations. In fact, averaging can potentially soften the contribution of features that are highly relevant only for few samples. Another interesting issue is how to choose the surrogate model to provide explanations for non-differentiable models. Some theoretical results show that, under certain assumptions, some learning algorithms can provide similar decision functions; e.g., nonlinear SVMs may reliably approximate random forests [19]. Nevertheless, it is still required to investigate how different surrogate models impact the explanations provided by our approach. These are all relevant issues towards the development of interpretable models, as required by the novel European General Data Protection Regulation (GDPR) [11]. The right of explanation stated by GDPR imposes to develop models that are transparent with respect to their decisions. We believe that this work is a first step towards this direction."
    },
    {
      "heading": "ACKNOWLEDGMENTS",
      "text": "This work was partly supported by the EU H2020 project ALOHA, under the European Union\u2019s Horizon 2020 research and innovation programme (grant no. 780788), and by the PISDAS project, funded by the Sardinian Regional Administration (CUP E27H14003150007)."
    }
  ],
  "title": "Explaining Black-box Android Malware Detection",
  "year": 2018
}
