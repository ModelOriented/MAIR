{
  "abstractText": "In cyberattack detection and prevention systems, cybersecurity analysts always prefer solutions that are as interpretable and understandable as rule-based or signature-based detection. This is because of the need to tune and optimize these solutions to mitigate and control the effect of false positives and false negatives. Interpreting machine learning models is a new and open challenge. However, it is expected that an interpretable machine learning solution will be domain specific. For instance, interpretable solutions for machine learning models in healthcare are different than solutions in malware detection. This is because the models are complex, and most of them work as a black-box. Recently, the increased ability for malware authors to bypass antimalware systems has forced security specialists to look to machine learning for creating robust detection systems. If these systems are to be relied on in the industry, then, among other challenges, they must also explain their predictions. The objective of this paper is to evaluate the current state-of-the-art ML models interpretability techniques when applied to ML-based malware detectors. We demonstrate interpretability techniques in practice and evaluate the effectiveness of existing interpretability techniques in the malware analysis domain.",
  "authors": [
    {
      "affiliations": [],
      "name": "Sherif Saad"
    }
  ],
  "id": "SP:07378f663274856c009026dc8f9a23a5e20ddc0d",
  "references": [
    {
      "authors": [
        "M. Alber",
        "S. Lapuschkin",
        "P. Seegerer",
        "M. Hgele",
        "K.T. Schtt",
        "G. Montavon",
        "W. Samek",
        "K.R. Mller",
        "S. Dhne",
        "P.J. Kindermans"
      ],
      "title": "innvestigate neural networks",
      "year": 2018
    },
    {
      "authors": [
        "D.W. Apley",
        "J. Zhu"
      ],
      "title": "Visualizing the effects of predictor variables in black box supervised learning models (2016",
      "venue": "Interpreting Machine Learning Malware Detectors",
      "year": 2016
    },
    {
      "authors": [
        "S. Bach",
        "A. Binder",
        "G. Montavon",
        "F. Klauschen",
        "K.R. M\u00fcller",
        "W. Samek",
        "O.D. Su\u00e1rez"
      ],
      "title": "On pixel-wise explanations for non-linear classifier decisions by layerwise relevance propagation",
      "venue": "PloS one",
      "year": 2015
    },
    {
      "authors": [
        "L. Breiman"
      ],
      "title": "Random forests",
      "venue": "Machine Learning 45(1), 5\u2013 32",
      "year": 2001
    },
    {
      "authors": [
        "R.D. Cook"
      ],
      "title": "Detection of influential observation in linear regression",
      "venue": "Technometrics 19(1), 15\u201318",
      "year": 1977
    },
    {
      "authors": [
        "J.H. Friedman"
      ],
      "title": "Greedy function approximation: A gradient boosting machine",
      "venue": "Ann. Statist. 29(5), 1189\u2013 1232",
      "year": 2001
    },
    {
      "authors": [
        "J.H. Friedman",
        "B.E. Popescu"
      ],
      "title": "Predictive learning via rule ensembles",
      "venue": "Ann. Appl. Stat. 2(3), 916\u2013954",
      "year": 2008
    },
    {
      "authors": [
        "A. Goldstein",
        "A. Kapelner",
        "J. Bleich",
        "E. Pitkin"
      ],
      "title": "Peeking inside the black box: Visualizing statistical learning with plots of individual conditional expectation",
      "venue": "Journal of Computational and Graphical Statistics 24",
      "year": 2013
    },
    {
      "authors": [
        "B. Kim",
        "R. Khanna",
        "O. Koyejo"
      ],
      "title": "Examples are not enough, learn to criticize! criticism for interpretability",
      "venue": "Proceedings of the 30th International Conference on Neural Information Processing Systems. pp. 2288\u20132296",
      "year": 2016
    },
    {
      "authors": [
        "P.W. Koh",
        "P. Liang"
      ],
      "title": "Understanding black-box predictions via influence functions",
      "venue": "Proceedings of the 34th International Conference on Machine Learning - Volume",
      "year": 2017
    },
    {
      "authors": [
        "C. Molnar"
      ],
      "title": "Interpretable Machine Learning",
      "venue": "GitHub",
      "year": 2019
    },
    {
      "authors": [
        "F.E. Otero",
        "A.A. Freitas"
      ],
      "title": "Improving the interpretability of classification rules discovered by an ant colony algorithm",
      "venue": "Proceedings of the 15th Annual Conference on Genetic and Evolutionary Computation. pp. 73\u201380. GECCO \u201913, ACM, New York, NY, USA",
      "year": 2013
    },
    {
      "authors": [
        "T. Peltola"
      ],
      "title": "Local interpretable model-agnostic explanations of bayesian predictive models via kullback-leibler projections",
      "venue": "ArXiv abs/1810.02678",
      "year": 2018
    },
    {
      "authors": [
        "E. Raff",
        "R. Zak",
        "R.J. Cox",
        "J. Sylvester",
        "P. Yacci",
        "R. Ward",
        "A. Tracy",
        "M. McLean",
        "C. Nicholas"
      ],
      "title": "An investigation of byte n-gram features for malware classification",
      "venue": "Journal of Computer Virology and Hacking Techniques 14, 1\u201320",
      "year": 2016
    },
    {
      "authors": [
        "M.T. Ribeiro",
        "S. Singh",
        "C. Guestrin"
      ],
      "title": "why should i trust you?\u201d: Explaining the predictions of any classifier",
      "venue": "Proceedings of the 22Nd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining. pp. 1135\u20131144. KDD \u201916, ACM, New York, NY, USA",
      "year": 2016
    },
    {
      "authors": [
        "R. Ronen",
        "M. Radu",
        "C. Feuerstein",
        "E. Yom-Tov",
        "M. Ahmadi"
      ],
      "title": "Microsoft malware classification challenge",
      "year": 2018
    },
    {
      "authors": [
        "A. Saabas"
      ],
      "title": "Treeinterpreter",
      "venue": "https://github.com/andosa/treeinterpreter",
      "year": 2015
    },
    {
      "authors": [
        "S. Shirataki",
        "S. Yamaguchi"
      ],
      "title": "A study on interpretability of decision of machine learning",
      "venue": "2017 IEEE International Conference on Big Data (Big Data). pp. 4830\u20134831",
      "year": 2017
    },
    {
      "authors": [
        "A. Shrikumar",
        "P. Greenside",
        "A. Kundaje"
      ],
      "title": "Learning important features through propagating activation differences",
      "venue": "ArXiv abs/1704.02685",
      "year": 2017
    },
    {
      "authors": [
        "E. Strumbelj",
        "I. Kononenko"
      ],
      "title": "An efficient explanation of individual classifications using game theory",
      "venue": "J. Mach. Learn. Res",
      "year": 2010
    },
    {
      "authors": [
        "S. Wachter",
        "B.D. Mittelstadt",
        "C. Russell"
      ],
      "title": "Counterfactual explanations without opening the black box: Automated decisions and the gdpr",
      "venue": "ArXiv abs/1711.00399",
      "year": 2017
    }
  ],
  "sections": [
    {
      "text": "ar X\niv :2\n00 1.\n10 91\n6v 1\n[ cs\n.C R\n] 2\n7 Ja\nn 20\nKeywords: Cybersecurity, Machine Learning, Malware Detection, NGram, Malware Detector Interpretability, Model Robustness, Model Reliability"
    },
    {
      "heading": "1 Introduction",
      "text": "Adopting sophisticated machine learning techniques for malware detection or other cyber attack detection and prevention systems in a production environment is a challenge. This is because most of the time it is not possible to understand how machine learning systems make their detection decisions. In the malware detection domain, machine learning models can be trained to distinguish between benign binaries and malware, or between different malware families. The advantage of using machine learning models is that they are less sensitive to minute changes in malware binaries and can therefore detect unseen samples so long as they are designed and trained to detect characteristics common across seen and unseen samples. Furthermore, they\u2019re learnt relationships can be used\nto determine relevant features for a classification, limiting the amount of data malware analyst must sift through to determine the functionality of a malicious binary. However, there are several drawbacks that must be addressed before their full potential can be realized in the malware detection domain. Firstly, due to the quick evolving nature of malware, the models must be made efficient to train and update frequently when new malware families are discovered. Secondly, it is possible to create specially crafted \u201cadversarial samples\u201d which take advantage of peculiarities in the models learnt relationships to bypass the detector with relatively inconsequential changes to the binary. Finally, given the high degree of risk involved with classification errors, the models must provide a reason for their decisions in order to improve performance and increase trust in the model and its predictions. This last point is the focus of this paper.\nThe process of providing reasons for a machine learning model\u2019s predictions is known as interpretation. Interpretation in this setting should provide several key benefits. Firstly, due to the high cost of classification error, a low false positive and false negative rate is a must, and therefore these systems must be robust. A model is said to be robust if small changes in input do not cause large changes in output such as a different classification Second, the high risk necessitates a high degree of model confidence. Therefore, interpretation must provide evidence that the model has learnt something which can be corroborated with industry knowledge. This also goes hand in hand with the first requirement as an interpretation which can show a model is robust can improve model confidence as well. Additionally, the interpretation should aid malware analysts in down stream tasks such as determining the functionality of a malware binary.\nMachine learning interpretation can be broadly separated into two categories. One is model agnostic techniques which are independent of the type of model which they are interpreting and rely solely on the input and output of the model. The other, which we will be using in this paper, are model specific techniques, which use specific elements of the model such as learnt weights or decision rules in order to provide an interpretation of a prediction. Interpretations themselves can be divided into global and local interpretations. Global interpretations provide an interpretation that is applicable across the entire feature space. Meanwhile local interpretations apply to only a single example or a small subset of the feature space. Some interpretation techniques provide only one type of interpretation while others provide both.\nIn this paper we explore the interpretability of machine learning based malware classifiers in relation to the goals of model robustness, confidence in model predictions, and aiding the process of determining the functionality of a malware sample. We train a logistic regression model, random forest, and a neural network on a Microsoft data set containing the hexadecimal representations of malware binaries belonging to several different malware families. We then apply model specific interpretation techniques to provide both a global and local interpretation of each of the models. The objective of this paper is to demonstrate interpretability techniques in practice on machine learning based malware detectors. We also try to evaluate the effectiveness of existing interpretability\ntechniques in the malware analysis domain in terms of their usefulness to malware analysts in a practical setting. To the best of our knowledge, this is the only work which explores the application of machine learning interpretability techniques in the malware analysis domain."
    },
    {
      "heading": "2 Literature Review",
      "text": "In the last decade, with the increasingly massive data sets machine learning algorithms are being used on, and the growing complexity of the algorithms, the prediction process of these algorithms has become so non-intuitive that traditional analysis techniques no longer suffice. Analysis being necessary for a number of practical and legal concerns has caused research to now shift towards machine learning interpretability.\nChristoph Molnar [11] put together a summary of machine learning interpretation methods in which he outlines a basic approach for the interpretation of Linear Regression models (of course the same approach can be applied to linear SVMs, Shirataki et al. [18]) where a features contribution to a prediction is the product of its value and weight. For logistic regression he shows that when the jth feature value is incremented by 1, then the quotient of the predicted odds of the sample belonging to the positive class after the increase over the predicted odds of the sample belonging to the positive class before the increase is equal to e\u03b2j , where \u03b2j is the weight of feature j. Alternatively, this means that a unit increase in feature j results in the predicted odds increasing by ((e\u03b2j \u22121)\u2217100)%. He goes on to discuss the seemingly trivial interpretation of decision trees as the conjunction of the conditions described in the nodes along a predictions path to a leaf node. Similarly, for rule list models, an \u201cexplanation\u201d is simply re-stating the rule or combination of rules which lead to a decision.\nHowever, the evaluation of a models complexity is closely tied with its explanations comprehensibility, especially for rule set models, linear models, and tree models. Given the following complexity definitions, the explanation approaches discussed above could be too complex for highly dimensional datasets. Marco Ribeiro et al. [15] define the complexity of a linear model as the number of non-zero weights and the complexity of a decision tree as the depth of the tree. Meanwhile, Otero and Freitas [12] defined the complexity of a list of rules as the average number of conditions evaluated to classify a set of test data. They referred to this as the \u201cprediction-explanation size\u201d.\nThere has also been work done on the interpretability of neural networks(NNs) such as the Layer-wise Relevance Propagation introduced in [3] as a set of constraints. The constraints ensure that the total relevance is preserved from one layer to another as well as that the relevance of each node is equal to the sum of relevance contributions from its input nodes which in turn is equal to the sum of relevance contributions to its output nodes. Any decomposition function following these constraints is considered a type of Layer-wise Relevance Propagation. In [19], Shrikumar et al. propose DeepLIFT which attributes to each node a contribution to the difference in prediction from a reference prediction by back\npropagating the difference in predication scaled by the difference in intermediate and initial inputs.\nMoving on to model agnostic methods, Friedman in [6] used Partial Dependence Plots (PDP) to show the marginal effect a feature has in a predictive model. Similarly, Goldstein et al. [8] used Individual Conditional Expectation (ICE) plots to show a curve for each sample in the data set where one or two features are free variables while the rest of the features remain fixed. Since ICE plots and PDPs do not work well with strongly correlated features, Deniel W. Apley et al. [2] proposed Accumulated Local Effects plots to display the average local effect a feature has on predictions.\nThe H-statistic was used by Friedman and Popescu in [7] (equations 44-46) to provide a statistical estimate of the interaction strength between features by measuring the fraction of variance not captured by the effects of single variables. Feature Importance was measured by Breiman [4] as the increase in model error after a feature\u2019s values are permuted (a.k.a. permutation importance).\nMarco Ribeiro et al. in [15] defined a version of the surrogate method which can explain individual predictions using an approach called Local Interpretable Model-agnostic Explanations (LIME) which trains an interpretable classifier by heavily weighing samples nearer to a sample of interest. Tomi Peltola [13] extended this work with KL-LIME, which generated local interpretable probabilistic models for Bayesian predictive models (although the method can also be applied to non-Bayesian probabilistic models) by minimizing the KullbackLeibler divergence of the predictive model and the interpretable model. This has the added benefit of providing explanations that account for model uncertainty. Strumbelj et al. [20] detailed how to describe the contributions made by each feature to a prediction for a specific instance using Shapely Values, a concept adopted from coalitional game theory.\nFinally, there are Example-Based methods such as the method put forward by Wachter et al. in [21] which produce interpretations by finding counter-factual examples which are samples with a significant difference in prediction, whose features are relatively similar to the sample of interest, by minimizing a loss function. The found sample is then used to explain what small changes would cause the original prediction to change meaningfully. There is also the MMD-critic algorithm by Kim et al. [9] which finds Prototypes (well represented examples) and Criticisms (poorly represented examples) in the dataset. To find examples in the training data which have a strong effect on a trained linear regression model (i.e. influential instances) Cook [5] proposed Cook\u2019s distance, a measure of the difference in predictions made by a linear regression model (however the measure can be generalized to any model) trained with and without an instance of interest. Koh and Liang [10] put forward a method for estimating the influence of a specific instance without retraining the model as long as the model has a twice differentiable loss function."
    },
    {
      "heading": "3 Method",
      "text": "Training and classification were done on a data set of 10,896 malware files belonging to 9 different malware families.1 The data set is discussed in [16]. Each sample consists of the hexadecimal representation of the malware\u2019s binary content. The class details are summed up in table 1.\nBased on other work on the the same data set, we decided to use n-grams as features. N-grams are sequences of words of length n which occur in a body of text. However, in our case the n-grams are sequences of bytes of length n which occur in a binary. The length of n-gram we settled on was 6 because they were shown to preform well in [14], however our approach can work with n-grams of arbitrary length. We extracted the 6-gram features from the hex representations of the malware files by obtaining the entire list of 6-grams present in the data set, and the number of files each 6-gram appeared in. This resulted in over 2,536,629,413 candidate features. Next, any 6-gram which did not appear in at least 100 files was removed from consideration, bringing the feature set size down to 817,785. This was done because [14] also showed that selection by frequency is an effective way to reduce the initial feature set size and a computationally cheap approach was needed considering the number of features.\nNext, feature vectors were created for each of the malware samples so that a more sophisticated feature selection method can be preformed. This was done by searching for the selected 6-gram feature in a binary and setting the corresponding value in that binary\u2019s feature vector to 1 if the binary did contain the 6-gram, and 0 otherwise. To select the features for the logistic regression model, Chi2 was used because it can detect if a categorical feature is independent of a predicted categorical variable (in this case our class) and is therefore irrelevant to our classifier. For the neural network and random forest, Mutual Information (MI) was used because it can detect the more complex dependencies between a feature and a sample\u2019s classification which can be taken advantage of by a neural\n1 The data set was downloaded from https://www.kaggle.com/c/malware-classification/data\nnetwork or random forest. Since the feature set was still very large, the Chi2 and MI scores had to be calculated in batches. This was done by splitting the data set into 20 batches, each with the same distribution of classes, and averaging out the resulting scores for each feature. Next, the features with Chi2 scores above 330 or MI scores above 0.415 were selected. This brought the feature set size down to 8867 in the case of the logistic regression model and to 9980 in the case of the neural network and random forest. The feature set size was determined based off other work using n-grams to classify the same data set. We did not attempt to find an optimal feature set size as our primary focus was model interpretation.\nNext, the models were trained on their respective feature sets. To find the best parameters for the logistic regression model and train the model, grid search with 5-fold cross validation was used, yielding C = 10 and tolerance = 0.0001. The value of C inversely determines the strength of regularization, that is, smaller values of C cause more feature weights in the classifier to be set to 0, a value of 0 corresponds to no regularization, and values above 0 encourage the classifier to use more features. Tolerance determines the minimum change in error, from one iteration of the optimization algorithm to the next, that causes the algorithm to terminate training. Similarly for random forest, finding the best parameters and training was done with grid search with 5-fold cross validation as well. The number of trees found to preform best was 300 and the and the minimum samples per leaf found to preform best was 0.01% of the total number of samples. The grid search with cross validation, logistic regression model, and the random forest model were implemented using the scikit python library.\nFor the neural network the data was split into a training and a test set each with the same class distribution. This was done because the extra parameters in a neural network require a larger data set to learn more abstract patterns and splitting it up into many folds might have stifled this process. The neural network consisted of an input layer with one neuron per feature, an output layer with one neuron per class using the sigmoid activation function, and a hidden layer consisting of 40 neurons using the tanh activation function. 40 neurons was chosen because that number was found to preform the best after testing with various other configurations. There were also no bias units to aid in interpretation. The neural network was implemented using the Keras python library.\nAfter training and testing the three models, the logistic regression model was interpreted by examining the weights used by the classifier. The random forest was interpreted by examining the feature importance as well as using the treeInterpreter python library [17] to obtain feature contributions to a particular prediction. In the case of the Neural network, the iNNvestigate python library by [1] was used to preform LRP to get the relevances of each node in the model for interpretation. The balanced accuracy on the left out fold was 96.19% for the logistic regression model and 96.97% for the random forest. The balanced accuracy on the test set was 94.22% for the neural network. A discussion of the model interpretations follows in the next section."
    },
    {
      "heading": "4 Interpretation",
      "text": ""
    },
    {
      "heading": "Logistic Regression Model Interpretation",
      "text": "The logistic regression model uses a one-vs-rest classification scheme whereby for each class, a constituent model is trained to classify a sample as either that class, or not that class, and therefore we are actually dealing with nine separate logistic regression models each making binary classifications. For this reason we cannot preform the typical global interpretation of the overall multi-class model by examining the weights since the weights should be different for each of the binary models. However, we can gain insight of the importance of each feature by averaging these weights across the 9 constituent binary models. For this we take the average of the absolute values of the weights. This is because if a feature contributes positively for one constituent binary classifier and negatively for another, then the weights would cancel each other out during averaging which would falsely give the impression that the feature was not important in the overall multi-class model. Table 2 shows the largest 15 averages of the absolute feature weights.\nLooking at the table 2, we can see that three 6-grams are relatively heavily weighted, 00E404000000, 0083C4088B4D, and C78530FDFFFF. Recall from section 2 that for logistic regression, when the jth feature value is incremented by a value of 1, then the predicted odds increase by ((e\u03b2j \u2212 1) \u2217 100)%, where \u03b2j is the learnt weight of the j\nth feature. In our case we are using binary feature values where a 1 indicates the presence of a 6-gram and 0 indicates its\nabsence, so we interpret the weights as follows. When the 6-gram corresponding to the jth feature is present, the predicted odds increase by ((e\u03b2j \u2212 1) \u2217 100)%. One may be tempted to apply this to the weights in table 2, but these are averaged absolute weights across all 9 constituent binary classifiers. Further, negative weights do not cause a decrease in the predicted odds that is proportional to a positive weight with the same absolute value due to the shape of the function f(x) = ex \u2212 1. Therefore, it would be inaccurate to say the average absolute effect of some 6-gram corresponds to a (eavgj \u2212 1)% change in the predicted odds, where avgj is the average absolute weight of feature j. Thus a global interpretation of a multi-class one-vs-rest logistic regression model using n-grams in confined to vague statements about which n-grams are important based solely off their average absolute weights, which is not very useful in a practical setting.\nNext we will examine the max weights for a constituent binary model. This will allow us to make conclusions on what features the model uses to detect a specific class of malware in the data set. Furthermore, we will be able to determine exactly the change in predicted odds that the presence of an n-gram causes. For the sake of brevity, we will examine just the binary model for class 3, corresponding to the Kelihos ver3 family of malware, as all three models performed well for this class but the same process can be followed for the other constituent binary models corresponding to other classes. Table 3 shows the max 15 weights of the classifier for class 3.\nIn table 3 we can see three 6-grams have relatively large weights. This means these n-grams are most strongly associated with class 3 and in this case, since we are looking at only the weights for a single binary classifier, we can use\nour interpretation from above. That is, when the 6-gram corresponding to the jth feature is present, the predicted odds increase by ((e\u03b2j \u2212 1) \u2217 100)%. For example we can say the presence of 00008B5DE43B, increases the predicted odds of a sample belonging to class 3 by ((e4.3916 \u2212 1) \u2217 100)% = 7977%. At first glance this number may seem excessive but in order to make good sense of it we must also determine what the predicted odds of a sample belonging to class 3 are when this 6-grams are not present, using a reference sample. For this we use a zero-vector corresponding to a sample where none of the 6-grams used as features are present. Since the dot product of a zero vector and the weight vector is zero, we only need to take the sigmoid of the intercept of the binary model for class 3 to determine the predicted probability of the reference vector belonging to class 3. The intercept is -4.2843, thus the predicted probability of the reference sample belonging to class 3 is sigmoid(\u22124.28426) = 0.01360. Next we must convert this to odds with 0.01360/(1\u2212 0.01360) = 0.01378. This means a sample with no feature 6-grams present except 00008B5DE43B increases the odds from 0.01378 by 7977% to 0.01378+ (0.01378 \u2217 79.77) = 1.11301 predicted odds, or a 0.5267 predicted probability, of belonging to class 3. Thus we see that because of the intercept, the large weight of this feature does not necessarily guarantee a classification into class 3.\nWe can get a better idea of the robustness of the model by checking the number of 6-grams which play a significant role in the classification of a sample into class 3. This is because robustness is a measure of how tolerant a model is to small changes in input. Therefore, if the number of 6-grams which play a significant role is large, then a large number of changes in input will be required for a change in classification, thus giving us confidence in the model\u2019s robustness. However, if the number of significant features is low then only a small number of changes in input will be required for a change in classification, changes that may be easy and inconsequential for malware authors to make. Thus the robustness of the model would be called into question. In our case, 20 features have weights greater than or equal to about 0.59. 6-grams with weights above this number increase the predicted odds by ((e0.59 \u2212 1) \u2217 100)% \u2248 80%. Since the predicted odds of the reference example belonging to class 3 is 0.01378, this means about 11 such features can cause a sample to be classified as class 3 with about 90% predicted probability. This may indicate that the model is putting too much emphasis on just a few highly weighted 6-grams. To test this we can reclassify samples belong to class 3 with the highest weighted 6-grams set to 0. In our case, we set the nine highest weighted features to 0 for all samples. This required 22863 changes to the feature array, and the result was only 24 more misclassifications, 17 of which belonged to class 3, which has 2942 samples. Here, we encounter a specification issue. Currently, there is no formally defined metric to measure robustness quantitatively and once there is, a threshold for acceptable robustness will be application specific. We leave a definition of a robustness metric to future work, however, given that robustness is defined in terms of a model\u2019s tolerance to changes in input, and that tolerance to changes of insignificant features is irrelevant, we can be confident that this approach can give us\nan idea of our model\u2019s robustness. The models robustness becomes more clear when compared with other models. For example, if setting the same number of features to 0 in another model resulted in more or less misclassification, then we can say that model is less or more robust respectively than our logistic regression model Therefore, we can confidently say our approach gave an idea of model robustness for class 3. One can increase the model\u2019s robustness by further training the classifier with samples which have the highly weighted 6-grams removed. This would force the classifier to learn a more diverse set of features which correspond to class 3, meaning that more changes would be required to change a prediction to or from class 3. Thus by observing the important features, we can improve the models robustness to small changes in the input. A similar strategy can be followed for the most negatively weighted features. If there are features with too large negative weights, then a detector can be fooled by intentionally adding these 6-grams. Further training the classifier by adding the large negative weighted 6-grams to samples labeled class 3 will force the classifier to learn not to negate positively weighted features with one or a small set of 6-grams. Therefore we can conclude that examining the weights in the manner we have done here can be useful for debugging logistic regression models leveraging n-grams. This interpretation is still global in that it encompasses the entire feature space, however, it must be repeated for each class. On the upside though, the global interpretation doubles as a local interpretation as the relationship between the presence of an n-gram and the change in the predicted odds holds across the entire data set for each sample.\nFurthermore, this method for finding important n-grams features can be helpful in a practical setting as it can be used to aid malware analysts in down stream tasks. A malware binary\u2019s functionality can be more easily determined by implementing a method which automatically disassembles binaries and highlights the code which corresponds to the most heavily weighted n-grams that are present in the binary. This approach can also improve confidence in the model if the highlighted code\u2019s functionality is corroborated with industry knowledge. Both these advantages require another interpretation step of mapping feature values from the feature space to the domain space (i.e. mapping n-grams to the corresponding code) which is not the focus of this paper. However, this can be a problem for future work as it is not an overly difficult problem to solve and as proof of concept, we provide an example of reverse mapping from n-gram feature to code snippet in appendix i. The downside to this interpretation approach is that it is specific to logistic regression models only, and unlike models such as neural networks or decisions tress, logistic regression models are not easily capable of learning more complex relationships between features and target values."
    },
    {
      "heading": "Random Forest Interpretation",
      "text": "In the case of the random forest, interpretation is more difficult. It is easy in a more general sense, in that we can get the feature importance scores, shown below in table 4, and use these to determine what features are generally most\nimportant, but getting a more fine grained interpretation is a challenge as the random forest is an ensemble of often hundreds of different decision trees.\nTable 4 gives us a great idea of the model robustness. Since the total feature importance is always equal to 1, we can be sure that the model isn\u2019t relying on just a small number of features to make predictions because the 15 most important features only accounts for 0.9% of the total importance. Additionally, the feature importance steadily declines without one feature or a small group of features overshadowing the rest. Unfortunately, general statements about robustness which do not provide much utility to the malware analyst in a practical setting are the most we can say with a global interpretation. However considering a single example can give us more information, albeit only locally."
    },
    {
      "heading": "Interpretation of a Single Sample with Random Forest",
      "text": "With random forest, a local interpretation of a single example is difficult as a classification decision is the result of a vote amongst many different decision trees. However, here we find the tree with the highest predicted probability that a specific example belongs to its actual class. Then we use the tree interpreter library [17] to break down the contributions of each 6-gram feature. In our case we followed this procedure for sample 4WM7aZDLCmlosUBiqKOx and found that the 6-gram 002500000031 and the bias contributed 97.3% of the total feature importance. One may be tempted to think this means the model is relying on only a single feature however this is just one tree out of many which have heavily varying structures. Thus, changing this feature may not cause many of\nthe other tree\u2019s predictions to change, such is the advantage of using random forests over single decisions trees. The significance of the resulting feature contribution is two fold. Firstly, the model designer can find the code corresponding to 002500000031 in the assembly code and determine weather the functionality of the code corroborates industry knowledge. If it does, then this can be used with other examples to improve model confidence. Secondly, by finding 6-grams in the constituent decision trees of the random forest model which are significant to a prediction, a process can be automated to disassemble the input file and highlight the code that corresponds to these significant 6-grams, aiding in malware analysis. The downside to this approach is that the random forest is made up of many different decision trees, many of which should all be predicting the correct class, so an automated process which collects significant 6-grams from these constituent trees and highlights the corresponding code may provide an overwhelming number of results. This is because well over a hundred trees will be contributing at least a few 6-grams, meaning that potentially 100\u2019s of snippets of code will be highlighted to the analyst. Once again we are faced with the problem of mapping the feature values to the domain, however this should not be too tall a task and we leave this challenge to future work."
    },
    {
      "heading": "Neural Network Model Interpretation",
      "text": "For our global interpretation of the Neural Network model, we used LRP to determine the most relevant input nodes for classification. LRP was preformed in this experiment using iNNvestigate python library by [1]. First we found the relevances of the input nodes for each sample and then we averaged the absolute values of these relevances for the entire data set. This was done because one input node may be positively contributing to one output nodes prediction while negatively contributing to another, causing the input nodes relevances to cancel out during averaging and giving false impressions about the feature set. Table 5 shows the largest 15 averages of the absolute relevances.\nIn Table 5 we can see two values had significantly higher relevances than the rest, 000000000400 and 0000000000FF, and are therefore important for the models classification. Additionally, we can see many of the features which appear here are also in the top 15 most important 6-grams for the random forest. This result partially validates our technique for finding important 6-gram features in a neural network which to the best of our knowledge is a novel use of LRP in this domain. This gives us a general idea of the importance of features used by the model but, just like in the case of the other two models, we are still confined to vague general statements about a feature\u2019s importance. However, this time it is due to the complexity of the model.\nNext we will examine the max relevances for a particular class. In this case we average the relevances for each node across all samples which were correctly classified as class 3. Table 6 shows the max 15 average relevances for class 3.\nIn Table 6 we can see five of the features which appear here are also in the top 15 highest weighted 6-grams for the binary logistic regression classifier for class 3. This result also partially validates our technique for finding important 6-gram\nfeatures in a neural network for a single class. In this case we are still confined to general statements about a features importance for a specific class. However, we can get an idea of the model\u2019s robustness by setting the features with the highest average relevances for class 3 to 0 for all correctly classified samples in class 3. If the model relies heavily on only the presence of these 6-grams, then the class accuracy will drop drastically, however if we have a similar class accuracy as before, then it is unlikely that the features with a lesser average relevance would have a larger effect on the class accuracy and therefore we can somewhat confidently say the model is robust for this class. In our experiment the top 4 highest average relevance features were all set to 0 and it resulted in no further misclassifications. Therefore we can say our model is somewhat robust for class 3. This result is somewhat helpful in a practical setting as a malware analyst can use this technique to ensure the robustness of their model, but not much else."
    },
    {
      "heading": "Interpretation of a Single Sample with Neural Network",
      "text": "Next we\u2019ll further explore the neural network\u2019s predictions for samples belonging to class 3 by taking the test sample with the highest predicted probability of belonging to class 3, sample 4WM7aZDLCmlosUBiqKOx, and examining relevances for this sample in order to provide a local interpretation. In doing so we can see what the internal nodes are learning. First we determine the internal node relevances for this sample. The library used for this experiment did not have a built in method to determine the relevances of internal layer nodes so we created a second neural network that was a duplicate of the last two layers of the original neural network. We then obtained the value of the second layer nodes before the activation function is applied when classifying this sample. That is, if W 1 is the weight matrix for the connections between layer 1 and layer 2, and X1 is the outputs of layer 1, then we obtained X1 \u00b7W 1. We then inputted X1 \u00b7W 1 into our second neural network and preformed LRP to get the relevances of the first layer of our second neural network which are equivalent to the relevances of the hidden layer in our original neural network. The most relevant node by a substantial margin was the 40th node in the hidden layer with a relevance of 0.61 and an activation of -0.99996614. Since this node is in layer 2 we will denote it with n240. Next we created a third neural network that had two layers. The first was identical to layer 1 of our original neural network, the second was just the single node, n240, from the original neural network, and the weight matrix for the connections from layer 1 to layer 2 of this new network is W 1(40) were W 1 (i) is the 9980-dimensional weight vector for connections from layer 1 to the ith node in layer 2 of the original neural network. In this way we were able to obtain the relevances of the input layer to only the activation of n240 in the hidden layer. Table 6 shows the max 10 node relevances for the activation of n240 in the hidden layer.\nIn table 7 we can see that many of the 6-grams have similar relevance\u2019s which slowly decrease. This corroborates our results when examining class 3 as a whole since the similar relevances across many input nodes indicates that many features\nare responsible for a classification which is to be expected when a model is robust to changes in the input data. One can automate the process of preforming LRP on specific examples to find relevant input nodes, both for the entire model and for a specific internal node possibly showing what the internal node is learning. From there highlighting the disassembled code which corresponds to the most relevant nodes can help malware analyst either determine the functionality of the file or show that the model has learnt something which corresponds to industry knowledge, thus improving confidence in the model."
    },
    {
      "heading": "5 Conclusion",
      "text": "In this paper we demonstrated techniques for the interpretation of malware detectors which leverage n-grams as features. We\u2019ve shown that it is possible to interpret a neural network, a logistic regression model, and a random forest, with the objectives of debugging and creating robust models, improving model confidence, and aiding malware analysts in downstream tasks. For the logistic regression model, examining the weights was all that was needed to meet these goals. However, although straight forward to interpret, the model was less expressive then the other two considered. The random forest required slightly more work for analysis but it was also possible to get a meaningful local interpretation that helped with the above stated goals. The downside here was that the random forest interpretation must consider many of constituent trees to be thorough, which can be time consuming and result in too much data. The neural network interpretation was much more intensive but by using layer-wise relevance propagation it was possible to determine the relevance or significance of different n-grams across the data set, across a specific class, and for a single example or for a single node. Thus, we were able to provide a global and local interpretation which was somewhat useful in a practical setting since by using these relevances it was then possible to get an idea of the robustness of the model and build confidence or aid in downstream analysis of samples. The approaches\noutlined here all revolve around the idea of feature significance and can thus be generalized to other models so long as there is a method for obtaining the significance of each feature across the data set or for a single example.\nOver all it was possible to satisfy our interpretation objectives for each model but the ubiquitous trade off between the interpretability and the expressively of the model was still present. Additionally, n-grams in and of themselves seem slightly problematic as it is not easy to determine what a n-gram corresponds to on its own, without considering a single example for context. So providing a global interpretation of a n-gram in order to show what the model has learnt is difficult. To this end it would be advantageous to include human readable features as well or other features which can be easily interpreted in a manner that doesn\u2019t require examining a real specific example. For future work we will focus on evaluating model agnostic techniques and enabling explanations in specific domain applications such as malware detection. Additionally, there is the open problem of a robustness metric definition in terms of the change in model accuracy when important features are \u201cturned off\u201d."
    },
    {
      "heading": "APPENDIX",
      "text": ""
    },
    {
      "heading": "Appendix i",
      "text": "In our experiment, it was possible to map n-gram features back to their corresponding assembly code snippet. We could do this automatically using Python regex to search for an n-gram in the hex representation of the malware binary, obtaining the address of the n-gram in the binary, then searching for said address in the assembly code .asm file.\nBelow is the code snippet with a 3 line padding on either side which corresponds to the n-gram D0 50 6A 00 E8 B8 in sample 4WM7aZDLCmlosUBiqKOx.\n.text :0063597 F 8B EC mov ebp , esp .text :00635981 83 EC 28 sub esp , 28h .text :00635984 8D 86 C0 FE FF FF lea eax , [esi -140 h] .text :0063598 A 13 D0 adc edx , eax .text :0063598 C 50 push eax .text :0063598 D 6A 00 push 0 .text :0063598 F E8 B8 FD FF FF call loc_63574C .text :00635994 83 C4 04 add esp , 4 .text :00635997 58 pop eax .text :00635998 50 push eax"
    }
  ],
  "year": 2020
}
